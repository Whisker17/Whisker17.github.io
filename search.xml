<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>探索椭圆曲线配对</title>
    <url>/2020/09/07/ECC-pairings/</url>
    <content><![CDATA[<p>原文：<a href="https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627">Exploring Elliptic Curve Pairings</a></p>
  <a id="more"></a>
<h1 id="探索椭圆曲线配对"><a href="#探索椭圆曲线配对" class="headerlink" title="探索椭圆曲线配对"></a>探索椭圆曲线配对</h1><p>椭圆曲线配对是各种密码学构造背后的关键原语之一，包括确定性阈值签名，zk-SNARK 和其他更简单形式的零知识证明。 椭圆曲线配对(也叫“双线性映射”)有了30年的应用历史，然而最近这些年才把它应用在密码学领域。 配对引入了一种“加密乘法”形式，极大地扩展了基于椭圆曲线的协议的应用范围。 本文的目的是详细介绍椭圆曲线配对，并解释其工作原理的概述。<br>第一次阅读本文，你可能有点地方无法弄明白，甚至是第10次阅读，你也可能无法完全明白 但是希望本文至少可以使您对幕后发生的事情有所了解。</p>
<p>椭圆曲线本身是一个不容易理解的话题，本文通常假定您知道它们是如何工作的。 如果不这样做，我建议您在此作为入门文章：<a href="https://blog.cloudflare.com/a-relatively-easy-to-under-understand-primer-on-elliptic-curve-cryptography/。">https://blog.cloudflare.com/a-relatively-easy-to-under-understand-primer-on-elliptic-curve-cryptography/。</a> 简要总结一下，椭圆曲线密码学涉及称为“点”的数学对象（这些点是具有（x，y）坐标的二维点），它有自己特别的加法和减法规则（即，用于计算R = P + Q），也可以将一个点乘以一个整数（即P * n = P + P +…+ P，但是如果 n 很大的话，则有一种更快的计算方法）。</p>
<p><img src="/.io//1_2PxXNwMceh1XC_waAP9NiA.jpeg" alt></p>
<p>存在一个特殊的点，称为“无穷大点”（O），在点算术中即为零。 即 P + O = P。此外，曲线具有“阶数”；存在一个数字 n ，使得任何P都为P <em> n = O（当然，P </em>（n + 1）= P，P <em>（7 </em> n + 5）= P <em> 5，依此类推）。也有一些公认的“生成元” G，从某种意义上讲，生成元 G 代表数字1。理论上，曲线上的任何点（O除外）都可以是 G ，就看选择哪一个作为标准。<br>我们进一步看下配对，它们使您可以检查椭圆曲线点上某些更复杂的方程式——例如，如果 P = G </em> p，Q = G <em> q 和 R = G </em> r ，当我们只有 P，Q 和 R 作为输入时，也可以检查是否 p <em> q = r 。这种形式看起来似乎椭圆曲线的基本安全保证已被破坏，因为关于 p 的信息是在我们只知道 P 的情况下而泄漏的，而事实证明泄漏是高度包含的——具体来说，<a href="https://en.wikipedia.org/wiki/Decisional_Diffie%E2%80%93Hellman_assumption">决策Diffie Hellman问题</a>很容易，但是计算 Diffie Hellman 问题（在上面的示例中知道 P 和 Q ，计算 R = G </em> p * q ）和离散对数问题（从 P 中恢复 p ）在计算上仍然不可行（至少在以前是这样）。</p>
<p>再进一步观察配对功能，也许对于我们所使用的大多数用例而言，最能说明问题的是，如果您将椭圆曲线点视为单向加密数字（即，encrypt（p） = p <em> G = P），则传统的椭圆曲线数学可以让我们检查数字的线性约束（例如，如果已知 P = G </em> p，Q = G <em> q 和 R = G </em> r ，则检查 5 <em> P + 7 </em> Q = 11 <em> R 实际上是在检查 5 </em> p + 7 <em> q = 11 </em> r ），而配对使我们可以检查二次约束（例如，检查e(P，Q) <em> e(G，G </em> 5) = 1 确实在检查 p * q + 5 = 0 ）。 升到二次就足以让我们使用确定性门限签名，QAP 和所有其他好东西。<br>现在，我们上面介绍的这个有趣的 e(P，Q) 运算符是什么？ 这就是配对。 数学家有时也称它为双线性图。 这里的“双线性”一词基本上意味着它满足约束条件：</p>
<script type="math/tex; mode=display">e(P, Q + R) = e(P, Q) * e(P, R)</script><script type="math/tex; mode=display">e(P + S, Q) = e(P, Q) * e(S, Q)</script><p>注意 + 和 <script type="math/tex">*</script> 可以是任意运算符;当你创造奇特的新类型的数学对象时，抽象代数并不关心如何定义 + 和 <script type="math/tex">*</script> ，只要它们与通常的运算方式保持一致就行，例如 a+b = b+a, <script type="math/tex">(a*b)*c = a*(b*c)</script> 以及 <script type="math/tex">(a*c) + (b*c) = (a+b)*c</script> 。</p>
<p>如果 P， Q， R 是单纯的数字，那么做个配对就简单了：我们可以定义 e(x, y) = 2^{xy} ，那么我们可以看到：</p>
<script type="math/tex; mode=display">e(3, 4+5) = 2^{3*9} = 2^{27}</script><script type="math/tex; mode=display">e(3, 4)*e(3, 5) = 2^{3*4} * 2^{3*5} = 2^{12} * 2^{15} = 2^{27}</script><p>它是双线性的。</p>
<p>然而，这种简单的配对不适用于密码学，因为它们所处理的对象是简单的整数，并且很容易分析；整数使得除法、对数运算和各种其他的运算变得容易；简单整数没有“公钥”或“单向函数”的概念。此外，通过上述配对，我们可以进行反推—— 知道 x 和 e(x,y) ，就可以通过简单地除法和对数计算来确定 y 。我们希望数学对象尽可能接近“黑盒子”，你可以在其中进行加，减，乘和除，但不做任何其他事情。这正是椭圆曲线和椭圆曲线配对的作用。</p>
<hr>
<p>事实证明，也可以在椭圆曲线点上制作双线性映射 ——即得出 e(P,Q) 函数，其中输入点 P 和 Q ，都是椭圆曲线点，并且输出是所谓的 F_p¹² 元素（至少在下面的情况下是这样的；具体情况因曲线细节而异，稍后会详细介绍），注意，这背后的数学非常复杂。</p>
<p>首先，让我们介绍素数域和扩展域。如果我们假设曲线方程是使用常规实数定义的，那么得到的椭圆曲线看上去就是像本文前面图片的那样。但是，如果我们真的在密码学中使用常规实数，那么你就可以轻易的使用对数运算进行反推，由此获得破解；此外，存储和表示数字所需的空间也会大幅增长。因此，我们改为使用素数域中的数字。</p>
<p>素数域由数字 0,1,2 … p-1 构成的集合组成，其中 p 为素数，各种操作定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a+b: (a+b) % p</span><br><span class="line">a*b: (a*b) % p</span><br><span class="line">a-b: (a-b) % p</span><br><span class="line">a&#x2F;b: (a*b^(p-2)) % p</span><br></pre></td></tr></table></figure>
<p>基本上，所有数学都以模 p 形式完成（有关模运算的介绍，请<a href="https://www.khanacademy.org/computing/computer-science/cryptography/modarithmetic/a/what-is-modular-arithmetic">参见此处</a>）。除法是一个特例；通常的运算中，3/2 的结果不是整数，然而这里我们只想处理整数，所以我们试图找到数 x，使得 x <em> 2 = 3 ，其中 </em> 是指如上定义的模乘。感谢 <a href="https://en.wikipedia.org/wiki/Fermat&#39;s_little_theorem">Fermat小定理</a> ，里面给出的取幂技巧可以帮助我们完成了这个计算，但使用扩展欧几里得算法可以更快一些。假设 p = 7 ；这里有一些例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 + 3 &#x3D; 5 % 7 &#x3D; 5</span><br><span class="line">4 + 6 &#x3D; 10 % 7 &#x3D; 3</span><br><span class="line">2 - 5 &#x3D; -3 % 7 &#x3D; 4</span><br><span class="line">6 * 3 &#x3D; 18 % 7 &#x3D; 4</span><br><span class="line">3 &#x2F; 2 &#x3D; (3 * 2^5) % 7 &#x3D; 5</span><br><span class="line">5 * 2 &#x3D; 10 % 7 &#x3D; 3</span><br></pre></td></tr></table></figure>
<p>如果你钻研一下这类数学计算，你会发现它是完备的并且满足所有通用的规则。上面的最后两个例子显示了 (a / b)<em> b = a ；你还可以看到(a + b)+ c = a +(b + c)，(a + b)</em> c = a <em> c + b </em> c，而且与你知道和喜爱的所有其他高中代数规律依然相符。在实际的椭圆曲线中，点和方程通常是在素数域中计算的。</p>
<p>现在，我们来谈谈扩展域。您之前可能已经看过一个扩展域；在数学教科书中遇到的最常见的例子是复数域，复数域实际上是，实数域加上 sqrt(-1)= i 的扩展。基本上，扩展域就是在现有域的基础上，“发明”一个新元素并定义该元素与现有元素之间的关系(比如，i²+ 1 = 0)，并确保此等式不适用于原有域中的任何数字，然后对现有域的元素和新创建的元素做一个线性组合。</p>
<p><img src="/.io//1_qDOPI299SKvZuzeNnik4JA.png" alt></p>
<p>我们也可以扩展素数域；例如，我们可以用 i 扩展我们上面描述的素数域 mod 7 ，然后我们可以这样做：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(<span class="number">2</span> + <span class="number">3i</span>) + (<span class="number">4</span> + <span class="number">2i</span>) = <span class="number">6</span> + <span class="number">5i</span></span><br><span class="line">(<span class="number">5</span> + <span class="number">2i</span>) + <span class="number">3</span> = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line">(<span class="number">6</span> + <span class="number">2i</span>) * <span class="number">2</span> = <span class="number">5</span> + <span class="number">4i</span></span><br><span class="line"><span class="number">4i</span> * (<span class="number">2</span> + i) = <span class="number">3</span> + i</span><br></pre></td></tr></table></figure>
<p>最后一个计算结果可能有点难懂。我们首先将乘积分解为 4i <em> 2 + 4i </em> i ，得到 8i  -  4 ，然后因为我们在 mod 7  质数域中，所以进行mod 7 运算后，变成 i + 3 。接下来， 对于除法，我们可以这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x2F; b:  (a * b^(p^2-2)) % p</span><br></pre></td></tr></table></figure>
<p>请注意，在这里 Fermat小定理的指数是 p² 而不是 p ，但如果我们想要更高效，我们也可以通过扩展“扩展的欧几里得算法”来完成这项工作。注意，对于该域中的任何 x ，x ^（p² -  1）= 1 ，因此我们将 p² - 1 称为“该域中乘法群的阶”。</p>
<p>在实数域中，<a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_algebra">代数的基本定理</a>保证了复数的二次扩展是“完备的” ——你不能再进一步扩展它了，因为对于任何数学关系（至少，由代数公式定义的任何数学关系），如果你增加了一个新的元素 j , 并观察它与现有复数的关系，你会发现总会有一个已经存在的复数满足了这种关系。然而对于素数域而言，不会有这样的问题，所以我们可以进一步做出三次扩展（其中一些新元素 w 和现有域元素之间的数学关系是一个三次方程，所以 1，w 和 w² 都是线性地并彼此独立），高阶扩展，扩展的扩展等。并且正是这种加强的、可求余的复数，构成了椭圆曲线配对的基础。</p>
<p>如果你想看下质数域和扩展域相关的数学计算及其代码实现，可以<a href="https://github.com/ethereum/research/blob/master/zksnark/bn128_field_elements.py">参考这里</a></p>
<hr>
<p>现在，进入椭圆曲线配对的内容。椭圆曲线配对（或者更确切地说，我们将在这里探讨的是配对的具体形式；其实还有其他类型的配对，不过它们的逻辑都非常相似）是一个映射 G2 x G1  - &gt; Gt ，其中</p>
<ul>
<li>G1 是一条椭圆曲线，它的点满足形如 y²=x³+ b 的等式，并且其中两个坐标都是 F_p 的元素（即，它们是简单的数字，不过，所有的算术运算都是对某个质数的模运算完成的）</li>
<li>G2 也是一条椭圆曲线，它的点满足与 G1 相同的等式，不过，坐标是 F_p¹² 的元素（即它们是我们前面谈到的加强版的复数；我们定义一个新的“魔数” w ，它是由 12 次多项式定义的，如 <code>w ^ 12 - 18 * w ^ 6 + 82 = 0</code>）</li>
<li>Gt 是椭圆曲线的结果所属的对象的类型。在我们当前的曲线中，Gt 是 F_p¹²（与 G2 中使用的是相同的加强版的复数）</li>
</ul>
<p>它必须满足的主要特性是双线性，在这种情况下意味着：</p>
<ul>
<li>e(P, Q+R) = e(P, Q) * e(P, R)</li>
<li>e(P+Q, R) = e(P, R) * e(Q, R)</li>
</ul>
<p>这里有两个重要的标准：</p>
<ul>
<li>高效的可计算性（例如，我们可以通过简单地获取所有点的离散对数并将它们相乘来进行简单的配对，但这与破解椭圆曲线加密的计算难度相同，因此这不可行）</li>
<li>不可退化性（当然，你可以定义 e(P,Q) = 1 ，但这不是一个特别有用的配对）</li>
</ul>
<p>我们如何做到这两点呢？</p>
<hr>
<p>配对函数背后的数学原理是非常棘手的，涉及到相当多的高等代数甚至超出了我们目前所见，但我将提供一个大纲。首先，我们需要定义除数的概念，它实际上是椭圆曲线上点的另一种函数表示方法。一个函数的除数基本上是计算这个函数的零和无穷大的个数。让我们来看几个例子。让我们已知点 P =（P_x，P_y） ，并考虑以下函数：<br>  f(x, y) = x - P_x </p>
<p>这个除数是 [P] + [-P] - 2* [O] （这里的方括号是表示，点 P 存在于函数的零和无穷大所组成的集合中，不是指P点本身；[P] + [Q]与[P+Q]不是同一种东西）。原因如下：</p>
<ul>
<li>这函数在 P 点的值是 0 ， 因为此时 x 等于 P_x ，代入 x - P_x = 0</li>
<li>这个函数在 -P 点的值也是 0 ， 因为 -P 和 P 的 x 坐标是相同的</li>
<li>当 x 趋近于无穷大的时候，这个函数也趋近去无穷大，所以我们说这个函数在 O 处是无穷大。这儿有一个问题，为什么这个无穷大需要计算两次，从而给 O 乘以 -2 呢？（取负是因为它是无穷大而不是零,2是说明计算了两次）</li>
</ul>
<p>技术上的原因大概是这样的：因为这个曲线方程是 x³ = y² + b 。y 趋近于无穷大的速度比 x 快 1.5 倍，这样才能使得 y² 赶上 x³ ；因此，如果一个线性函数只包含 x ，那么它代表着无穷大乘以 2 ，但是如果它包含 y ，那么它就代表无穷大乘以 3 。</p>
<p>现在，考虑一个线性函数：</p>
<p>ax + by + c = 0</p>
<p>这里，a,b 和 c 都是精心选择的，使得这条直线经过点 P 和 Q 。因为这正是椭圆曲线加法的方式(看下面图的上方),这也就意味着，它经过 -P-Q ，而后趋向于无穷大，同时考虑到它包含 x 和 y ，所以它的除数就是： [P]+ [Q] + [-P-Q] - 3 * [O] 。</p>
<p><img src="/.io//9787609-087ecfd2061758ce.webp" alt></p>
<p>我们知道每个“有理函数”(是指在点坐标系中有有限的数字进行加减乘除运算得到的函数)都唯一对应某个除数，最多也不过是再乘以一个常数（例如：如果两个函数有相同的除数，那么就满足 F=G*k ，k 是某个常数）</p>
<p>对于任意两个函数 F 和 G ，<script type="math/tex">F*G</script> 的除数等于 F 的除数加上 G 的除数(在数学课本中，你会看到 (F<em>G) = (F)+(G) )，举个例子，如果 f(x, y) = P_x -x , 那么 (f³) = 3 </em> [P] + 3 <em> [-P] - 6 </em> [O] ;<br> P 和 -P 计算了三次，是因为，在某种数学意义上， f³ 在这些点趋近于 0 的速度快了 3 倍。</p>
<p>现在，我们准备看一下 Tate 配对。考虑下面通过除数定义的函数：</p>
<ul>
<li>(F_P) = <script type="math/tex">n*[P] - n*[O]</script>，其中 n 是 G1 的阶，即对于任意的 P ，都有 n*P = O</li>
<li>(F_Q) = <script type="math/tex">n*[Q] - n*[O]</script></li>
<li>(g) = [P+Q] - [P] -[Q] +[O]</li>
</ul>
<p>现在我们看看这个乘积：F_P <em> F_Q </em> g^n 【译者注：利用上面的公式：<script type="math/tex">(F*G) = (F)+(G)</script>】。它的除数是：<br> n<em>[P] - n</em>[O] + n<em>[Q] - n</em>[O] + n<em>[P+Q] - n</em>[P] -n<em>[Q] + n</em>[O]<br> 简化后变成：<br> n<em>[P+Q] - n</em>[O]</p>
<p>注意，这个除数和上面F<em>P和F_Q的除数是同样的格式，因此：<br> F_P <em> F_Q </em>g ^n = F</em>(P+Q)。</p>
<p>现在，我们引入一种过程，叫做“最终取幂”，我们把上面函数 (F<em>P，F_Q) 的结果增加 z 次幂， z = (p¹² - 1) / n, 其中 p¹² - 1 是 F_p¹² 乘法群的阶(即对于任意 xϵ F_p¹², x^(p¹² - 1) = 1 )。注意，如果你把这个幂应用到任何<em>已经</em>有 n 次幂的结果上，你将得到 p¹² - 1 次幂，所以结果就变成 1了。因此，在最终取幂之后，g^n 就抵消掉了，我们有 F_P^z * F_Q^z = F</em>(P+Q)^z 。这正是我们需要的双线性。</p>
<p>现在，如果你想在两个参数中创建一个双线性函数，你需要进入更加诡异的数学，不要直接取 F_P 中的一个值，而是取 F_P 中的数作为一个除数，这就是完整的“ Tate 配对”了。为了证明更多的结果，你必须处理像“线性等价”和“ Weil 互惠”这样的概念，由此打开新世界的大门。您可以在<a href="http://www.math.ru.nl/~bosma/Students/MScThesis_DennisMeffert.pdf">这里</a>和<a href="http://people.cs.nctu.edu.tw/~rjchen/ECC2012S/Elliptic Curves Number Theory And Cryptography 2n.pdf">这里</a>找到更多关于所有这些的阅读材料。</p>
<p>对于 Tate 配对的修改版本的实现，称为最佳 Ate 配对，请参见<a href="https://github.com/ethereum/research/blob/master/zksnark/bn128_pairing.py">此处</a>。该代码实现了<a href="https://crypto.stanford.edu/pbc/notes/ep/miller.html">Miller</a>的算法，这是实际计算 F_P 所需的。</p>
<hr>
<p>请注意，像这样的配对事实上可能是一种混合的祝福：一方面，它意味着我们可以用配对做的所有协议都能实现，但也意味着我们必须更加小心的选择椭圆曲线。</p>
<p>每一个椭圆曲线都有一个叫做“嵌入度”的值；即，使得 p ^ k-1 是 n 的倍数（其中p是用于域的素数，n是曲线的阶），满足这一要求的最小的 k 。在上面的域中，k = 12，并且在用于传统ECC的应用场景中（即，我们不关心配对），嵌入度通常非常大，以至于配对在计算上是不可行的；但是，如果我们不小心，就可能生成 k = 4 或甚至 k=1 的域。</p>
<p>如果 k = 1 ，那么椭圆曲线的“离散对数”问题（即，只知道点 P = G * p 从而反推 p ，你需要解决的问题是“破解”椭圆曲线私钥）可以减少进入类似于 F_p 的数学问题，问题变得更容易（这称为 <a href="https://crypto.stanford.edu/pbc/notes/elliptic/movattack.html">MOV攻击</a>）;使用嵌入度为 12 或更高的曲线确保这种减少不可用，或者解决配对结果中的离散对数问题至少与从公共密钥“正常”恢复私钥一样困难（即，计算上是不可行的）。别担心，所有标准曲线已针对此问题彻底检查了参数。</p>
<p>之后我会写一篇博文，对 zk-SNARKs 的工作原理的数学解释，敬请期待。</p>
]]></content>
      <categories>
        <category>blockchain | ZKP | 翻译</category>
      </categories>
  </entry>
  <entry>
    <title>插值法综述</title>
    <url>/2020/08/18/Interpolation/</url>
    <content><![CDATA[<p>插值法的<strong>中心思想</strong>就是：</p>
<p><strong>在我们已具备一组 KV 键值对的情况下，如何得出还没被定到的区域的值</strong></p>
<p>使用插值法所建立的函数，在构造的函数中一定要重现原本给定的 KV 键值对，否则就不是插值法而是函数近似或者曲线拟合的问题了</p>
<p>插值的做法，直观来讲就是：</p>
<ol>
<li><p>先从 KV 键值对来获得函数 f(x)</p>
</li>
<li><p>用函数 f(x) 求出我们所要的任何特定 x 之 f(x )  函数值。</p>
</li>
</ol>
<a id="more"></a>
<p>然而，比较精密且系统化的数值方法却不是用这两个步骤来进行插值，原因是前述两阶段方法<strong>对于插值的精密度并没有控制</strong>，效率较差，也比较会有进位误差。一般在做插值法，是从欲插值点 x 附近的几个 KV 键值对 xi 开始，建立插值函数 f(x) ，并且也试着网罗更多 KV 键值对来插值，看随着项数变多误差会不会变小，如此找出最适合的函数 f(x) 。</p>
<h2 id="线性插值法"><a href="#线性插值法" class="headerlink" title="线性插值法"></a>线性插值法</h2><p>所有的插值法里面最简单的莫过于线性插值法，任两个相邻的点之间必可以拉一条直线把它们连起来，如此在之间的 x 值就都有线性函数 y(x ) 可以对应到，利用直线上的斜率必为固定值的特性</p>
<p><img src="/.io//2020-08-19_00-03.png" alt="2020-08-19_00-03"></p>
<h2 id="多项式插值法"><a href="#多项式插值法" class="headerlink" title="多项式插值法"></a>多项式插值法</h2><p>现存的各种多项式插值法最终都是通过假设多项式方程求解方程参数的问题，也就是矩阵求解的问题。</p>
<h3 id="线性方程"><a href="#线性方程" class="headerlink" title="线性方程"></a>线性方程</h3><p>假设我们现在已知 k 个在二维平面上的点，那么我们可以连立这些点组成一个 k-1 次的方程组，从而解出这个方程组的各个系数。</p>
<p>例如：</p>
<p> <img src="https://www.zhihu.com/equation?tex=y%3DAx%5E2%2BBx%2BC" alt="[公式]"></p>
<p>当我们有 3 个点的时候，我们联立的方程是</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+Ax_0%5E2%2BBx_0%2BC%26%3Dy_0%5C%5C+Ax_1%5E2%2BBx_1%2BC%26%3Dy_1%5C%5C+Ax_2%5E2%2BBx_2%2BC%26%3Dy_2+%5Cend%7Balign%7D" alt="[公式]"></p>
<p><em>变为矩阵求解问题，结合<strong>克莱姆法则(Cramer‘s Rule)</strong> 我们可以很快得出</em><br><img src="https://www.zhihu.com/equation?tex=A%3D%5Cfrac%7B%5Cbegin%7Bvmatrix%7D+y_0+%26+x_0+%26+1+%5C%5C+y_1+%26+x_1+%26+1+%5C%5C+y_2+%26+x_2+%26+1+%5Cend%7Bvmatrix%7D%7D%7B%5Cbegin%7Bvmatrix%7D+x_0%5E2+%26+x_0+%26+1+%5C%5C+x_1%5E2+%26+x_1+%26+1+%5C%5C+x_2%5E2+%26+x_2+%26+1+%5Cend%7Bvmatrix%7D%7D%2C%5C+B%3D%5Cfrac%7B%5Cbegin%7Bvmatrix%7D+x_0%5E2+%26+y_0+%26+1+%5C%5C+x_1%5E2+%26+y_1+%26+1+%5C%5C+x_2%5E2+%26+y_2+%26+1+%5Cend%7Bvmatrix%7D%7D%7B%5Cbegin%7Bvmatrix%7D+x_0%5E2+%26+x_0+%26+1+%5C%5C+x_1%5E2+%26+x_1+%26+1+%5C%5C+x_2%5E2+%26+x_2+%26+1+%5Cend%7Bvmatrix%7D%7D%2C%5C+C%3D%5Cfrac%7B%5Cbegin%7Bvmatrix%7D+x_0%5E2+%26+x_0+%26+y_0+%5C%5C+x_1%5E2+%26+x_1+%26+y_1+%5C%5C+x_2%5E2+%26+x_2+%26+y_2+%5Cend%7Bvmatrix%7D%7D%7B%5Cbegin%7Bvmatrix%7D+x_0%5E2+%26+x_0+%26+1+%5C%5C+x_1%5E2+%26+x_1+%26+1+%5C%5C+x_2%5E2+%26+x_2+%26+1+%5Cend%7Bvmatrix%7D%7D" alt="[公式]"></p>
<p>以上公式可用的前提是分母不为 0，很多资料中在提到插值算法的时候要求各个点互异也是这个原因。实际上这间接证明了插值函数在一定次数上的解的唯一性，如果我们刚刚假设的是一个 3 次多项式，却只有 3 个点，方程就变为了 3 行 4 列，解是无穷的。因此我们才可以说在 n 个点互异的情况下可以确定唯一一个 n-1 次多项式。</p>
<p>但是线性方程组在实际应用中是有重大缺陷的：</p>
<ol>
<li>计算量大，如果是几万几十万的数据量，方程组的解将会非常耗时。</li>
<li>如果要新增加一组数据，整个方程组就会发生改变，要重新计算</li>
</ol>
<p>于是乎，我们引入了<strong>牛顿插值法</strong></p>
<h3 id="牛顿插值法"><a href="#牛顿插值法" class="headerlink" title="牛顿插值法"></a>牛顿插值法</h3><p>牛顿插值法的特点在于：<strong>每增加一个点，不需要推翻之前的计算，只需要计算和新增加的点相关的多项式就可以了。</strong></p>
<p>假设已知 <img src="https://www.zhihu.com/equation?tex=n%2B1" alt="[公式]"> 个点相对多项式函数 <img src="https://www.zhihu.com/equation?tex=f" alt="[公式]"> 的值为：<img src="https://www.zhihu.com/equation?tex=%28x_0%2Cf%28x_0%29%29%2C%28x_1%2Cf%28x_1%29%29%2C%28x_2%2Cf%28x_2%29%29%2C+%5Ccdots+%2C%28x_+n%2Cf%28x_+n%29%29" alt="[公式]"> ，求此多项式函数 <img src="https://www.zhihu.com/equation?tex=f" alt="[公式]"> 。</p>
<p><img src="/.io//v2-760da819b88578dde14769747402971a_720w.png" alt="v2-760da819b88578dde14769747402971a_720w"></p>
<p><img src="/.io//v2-f5d582849a959ace34d56c6cf39dc124_720w.jpg" alt="v2-f5d582849a959ace34d56c6cf39dc124_720w"></p>
<p>先从求满足两个点 <img src="https://www.zhihu.com/equation?tex=%28x_0%2Cf%28x_0%29%29%2C%28x_1%2Cf%28x_1%29%29" alt="[公式]"> 的函数 <img src="https://www.zhihu.com/equation?tex=f_1%28x%29" alt="[公式]"> 说起：</p>
<p>假设 <img src="https://www.zhihu.com/equation?tex=f_1%28x%29%3Df%28x_0%29%2Bb_1%28x-x_0%29" alt="[公式]"> ，</p>
<p>令 <img src="https://www.zhihu.com/equation?tex=f_1%28x_1%29%3Df%28x_1%29" alt="[公式]"> ：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%2A%7D+%26+%5Cimplies+b_1%3D%5Cfrac%7Bf%28x_1%29-f%28x_0%29%7D%7Bx_1-x_0%7D+%5C%5C+%26+%5Cimplies+f_1%28x%29%3Df%28x_0%29%2B%5Cfrac%7Bf%28x_1%29-f%28x_0%29%7D%7Bx_1-x_0%7D%28x-x_0%29+%5Cend%7Balign%2A%7D%5C%5C" alt="[公式]"></p>
<p>现在我们增加一个点， <img src="https://www.zhihu.com/equation?tex=%28x_0%2Cf%28x_0%29%29%2C%28x_1%2Cf%28x_1%29%29%2C%28x_2%2Cf%28x_2%29%29" alt="[公式]"> ，求满足这三个点的函数 <img src="https://www.zhihu.com/equation?tex=f_2%28x%29" alt="[公式]">：</p>
<p>假设 <img src="https://www.zhihu.com/equation?tex=f_2%28x%29%3Df_1%28x%29%2Bb_2%28x-x_0%29%28x-x_1%29" alt="[公式]"> ，</p>
<p>令 <img src="https://www.zhihu.com/equation?tex=f_2%28x_2%29%3Df%28x_2%29" alt="[公式]">：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%2A%7D+%26+%5Cimplies+b_2%3D%26+%26+%5Cfrac%7B%5B%5Cfrac%7Bf%28x_2%29+-+f%28x_1%29%7D%7Bx_2+-+x_1%7D%5D+-+%5B%5Cfrac%7Bf%28x_1%29+-+f%28x_0%29%7D%7Bx_1+-+x_0%7D%5D%7D%7Bx_2+-+x_0%7D+%5C%5C+%26+%5Cimplies+f_2%28x%29+%3D+%26+%26+f%28x_0%29%2B%5Cfrac%7Bf%28x_1%29-f%28x_0%29%7D%7Bx_1-x_0%7D%28x-x_0%29+%5C%5C+%26+%26+%26+%2B%5Cfrac%7B%5B%5Cfrac%7Bf%28x_2%29+-+f%28x_1%29%7D%7Bx_2+-+x_1%7D%5D+-+%5B%5Cfrac%7Bf%28x_1%29+-+f%28x_0%29%7D%7Bx_1+-+x_0%7D%5D%7D%7Bx_2+-+x_0%7D%28x-x_0%29%28x-x_1%29+%5Cend%7Balign%2A%7D%5C%5C" alt="[公式]"></p>
<p><img src="https://www.zhihu.com/equation?tex=b_1%2Cb_2" alt="[公式]"> 看起来蛮有特点的，我们把特点提炼一下。</p>
<p>一阶均差：</p>
<p><img src="https://www.zhihu.com/equation?tex=f%5Bx_+i%2Cx_+j%5D%3D%5Cfrac%7Bf%28x_+i%29-f%28x_+j%29%7D%7Bx_+i-x_+j%7D%2Ci%5Cne+j%5C%5C" alt="[公式]"></p>
<p>二阶均差是一阶均差的均差：</p>
<p><img src="https://www.zhihu.com/equation?tex=f%5Bx_+i%2Cx_+j%2Cx_+k%5D%3D%5Cfrac%7Bf%5Bi%2Cj%5D-f%5Bj%2Ck%5D%7D%7Bx_+i-x_+k%7D%2Ci%5Cne+j%5Cne+k%5C%5C" alt="[公式]"></p>
<p>三阶均差就是二阶均差的均差，以此类推，我们得到牛顿插值法为：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%2A%7D+f%28x%29+%3D%26+f%28%7Bx_0%7D%29+%2B+f%5B%7Bx_0%7D%2C%7Bx_1%7D%5D%28x+-+%7Bx_0%7D%29+%5C%5C+%26+%2B+f%5B%7Bx_0%7D%2C%7Bx_1%7D%2C%7Bx_2%7D%5D%28x+-+%7Bx_0%7D%29%28x+-+%7Bx_1%7D%29+%2B%5Ccdots+%5C%5C+%26+%2B+f%5B%7Bx_0%7D%2C%7Bx_1%7D%2C+%5Ccdots+%2C%7Bx_%7Bn+-+2%7D%7D%2C%7Bx_%7Bn+-+1%7D%7D%5D%28x+-+%7Bx_0%7D%29%28x+-+%7Bx_1%7D%29+%5Ccdots+%28x+-+%7Bx_%7Bn+-+2%7D%7D%29%28x+-+%7Bx_%7Bn+-+1%7D%7D%29+%5C%5C+%26+%2B+f%5B%7Bx_0%7D%2C%7Bx_1%7D%2C+%5Ccdots+%2C%7Bx_%7Bn+-+1%7D%7D%2C%7Bx_+n%7D%5D%28x+-+%7Bx_0%7D%29%28x+-+%7Bx_1%7D%29+%5Ccdots+%28x+-+%7Bx_%7Bn+-+1%7D%7D%29%28x+-+%7Bx_+n%7D%29+%5Cend%7Balign%2A%7D%5C%5C" alt="[公式]"></p>
<p>计算通过下面这个示意图进行，就会很简单：</p>
<p><img src="/.io//src/github.com/Whisker17/blog-source/blog/source/_posts/Interpolation/v2-bb250de06e4ce4d88f31bfd7cc8b9df7_720w.jpg" alt="v2-bb250de06e4ce4d88f31bfd7cc8b9df7_720w"></p>
<p>新增一个点就只需要计算相关的差分就可以了：</p>
<p><img src="/.io//src/github.com/Whisker17/blog-source/blog/source/_posts/Interpolation/v2-7caee6961c1c372e6743039b2ae32326_720w.jpg" alt="v2-7caee6961c1c372e6743039b2ae32326_720w"></p>
<h3 id="拉格朗日插值法"><a href="#拉格朗日插值法" class="headerlink" title="拉格朗日插值法"></a>拉格朗日插值法</h3><p><strong>Lagrange在构造函数的时候就是利用了零点的特性，用基函数的现行组合来实现。</strong></p>
<p>通常我们说基的时候是在说组成空间的不相同的元素，比如基向量组成向量空间，那么基函数的线型组合就构成了一个函数空间。<br><img src="https://www.zhihu.com/equation?tex=L%28x%29%3Da_0l_0%28x%29%2Ba_1l_1%28x%29%2Ba_2l_2%28x%29%2B%5Ccdots%2Ba_nl_n%28x%29" alt="[公式]"></p>
<p>其中 <img src="https://www.zhihu.com/equation?tex=l_i%28x%29+" alt="[公式]"><em>为基函数</em> <img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]"> 为常数</p>
<p>如果我们让 <img src="https://www.zhihu.com/equation?tex=a_i" alt="[公式]"><em>直接等于</em> <img src="https://www.zhihu.com/equation?tex=y_i" alt="[公式]"> 那我们就只需要构造对应的 <img src="https://www.zhihu.com/equation?tex=l_i%28x_i%29%3D1%2Cl_i%28x_j%29%3D0" alt="[公式]"> 就好了<br>一次的条件下 <img src="https://www.zhihu.com/equation?tex=%28x-x_j%29" alt="[公式]"><em>满足等于0的条件，</em>二次的条件下<em> <img src="https://www.zhihu.com/equation?tex=%28x-x_%7Bj1%7D%29%28x-x_%7Bj2%7D%29" alt="[公式]"></em>同理。<em>
</em>加上对应的分母就可以满足条件一。*</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+l_i%28x%29%26%3D%5Cprod_%7Bj%3D0%2Cj%5Cnot+%3D+i%7D%5En%5Cfrac%7B%28x-x_j%29%7D%7B%28x_i-x_j%29%7D%5C%5C+L%28x%29%26%3D%5Csum_%7Bi%3D0%7D%5Eny_i%5Cprod_%7Bj%3D0%2Cj%5Cnot+%3D+i%7D%5En%5Cfrac%7B%28x-x_j%29%7D%7B%28x_i-x_j%29%7D+%5Cend%7Balign%7D" alt="[公式]"></p>
<p>如果要找到某种和唯一解的对应关系，我们看一下<strong>克莱姆法则</strong>中的A的分母，是个<strong>范德蒙(Vandermonde)</strong>行列式，可以展开成 <img src="https://www.zhihu.com/equation?tex=V%3D%5Cprod%7Bn%5Cge+i%5Cgt+j%5Cge+0%7D%5En%28xi-xj%29" alt="[公式]"><em>,</em> 如果我们找到所有 <img src="https://www.zhihu.com/equation?tex=x" alt="[公式]"> 的二次项，加在一起，将分母变成V，就会发现分子是 <img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Bvmatrix%7D+y_0+%26+x_0+%26+1+%5C%5C+y_1+%26+x_1+%26+1+%5C%5C+y_2+%26+x_2+%26+1+%5Cend%7Bvmatrix%7D" alt="[公式]"> 行列式按第一列展开而已。</p>
<h3 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a>泰勒公式</h3><p>泰勒把牛顿插值法做了一些改造。</p>
<p>首先，设 <img src="https://www.zhihu.com/equation?tex=f%28x%29" alt="[公式]"> 是一个函数，它在 <img src="https://www.zhihu.com/equation?tex=x_0%2Cx_0%2B%5CDelta+x%2Cx_0%2B2%5CDelta+x%2Cx_0%2B3%5CDelta+x%2C%5Ccdots+%2Cx_0%2Bn%5CDelta+x" alt="[公式]"> 的值已知（和之前的相比，相当于每个点都是等距离间隔的，间隔 <img src="https://www.zhihu.com/equation?tex=%5CDelta+x" alt="[公式]"> ），令：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5CDelta+f%28x_0%29%3Df%28x_0%2B%5CDelta+x%29-f%28x_0%29" alt="[公式]"> ，也称为一阶差分，</p>
<p><img src="https://www.zhihu.com/equation?tex=%5CDelta+f%28x_0%2B%5CDelta+x%29%3Df%28x_0%2B2%5CDelta+x%29-f%28x_0%2B%5CDelta+x%29" alt="[公式]"> ，</p>
<p><img src="https://www.zhihu.com/equation?tex=%5CDelta+f%28x_0%2B2%5CDelta+x%29%3Df%28x_0%2B3%5CDelta+x%29-f%28x_0%2B2%5CDelta+x%29" alt="[公式]"></p>
<p>进一步令：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5CDelta+%5E2+f%28x_0%29%3D%5CDelta+f%28x_0%2B%5CDelta+x%29-%5CDelta+f%28x_0%29" alt="[公式]"> ，也称为二阶差分（为一阶差分的差分）</p>
<p><img src="https://www.zhihu.com/equation?tex=%5CDelta+%5E3+f%28x_0%29%3D%5CDelta+%5E2+f%28x_0%2B%5CDelta+x%29-%5CDelta+%5E2+f%28x_0%29" alt="[公式]"> ，也称为三阶差分。</p>
<p>做了这些假设之后我们来看看之前提到的 <img src="https://www.zhihu.com/equation?tex=b_1" alt="[公式]"> 会变成什么样子：</p>
<p><img src="https://www.zhihu.com/equation?tex=b_1%3D%5Cfrac%7Bf%28x_1%29-f%28x_0%29%7D%7Bx_1-x_0%7D%5Cimplies+b1%3D%5Cfrac%7B%5CDelta+f%28x_0%29%7D%7B%5CDelta+x%7D%5C%5C" alt="[公式]"></p>
<p>而 <img src="https://www.zhihu.com/equation?tex=f_1%28x%29" alt="[公式]"> 会变成：</p>
<p><img src="https://www.zhihu.com/equation?tex=f_1%28x%29%3Df%28x_0%29%2B%5Cfrac%7Bf%28x_1%29-f%28x_0%29%7D%7Bx_1-x_0%7D%28x-x_0%29%5Cimplies+f_1%28x%29%3Df%28x_0%29%2B%5Cfrac%7B%5CDelta+f%28x_0%29%7D%7B%5CDelta+x%7D%28x-x_0%29%5C%5C" alt="[公式]"></p>
<p>同样的 <img src="https://www.zhihu.com/equation?tex=f_2%28x%29" alt="[公式]"> 就变成了：</p>
<p><img src="https://www.zhihu.com/equation?tex=f_2%28x%29%3Df%28x_0%29%2B%5Cfrac%7B%5CDelta+f%28x_0%29%7D%7B%5CDelta+x%7D%28x-x_0%29%2B%5Cfrac%7B%5CDelta+%5E2+f%28x_0%29%7D%7B2%5CDelta+x%7D%28x-x_0%29%28x-x_1%29%5C%5C" alt="[公式]"></p>
<p>泰勒断言，当 <img src="https://www.zhihu.com/equation?tex=%5CDelta+x%3D0" alt="[公式]"> 时：</p>
<p><img src="https://www.zhihu.com/equation?tex=f_1%28x%29%3Df%28x_0%29%2Bf%27%28x_0%29%28x-x_0%29%5C%5C" alt="[公式]"></p>
<p><img src="https://www.zhihu.com/equation?tex=f_1%28x%29%3Df%28x_0%29%2Bf%27%28x_0%29%28x-x_0%29%2B%5Cfrac%7Bf%27%27%28x_0%29%7D%7B2%21%7D%28x-x_0%29%5E2%5C%5C" alt="[公式]"></p>
<p>（ <img src="https://www.zhihu.com/equation?tex=%5CDelta+x%3D0" alt="[公式]"> 时有 <img src="https://www.zhihu.com/equation?tex=x-x_1%3Dx-x_0" alt="[公式]"> ）</p>
<p>以此类推泰勒就得到了大名鼎鼎的泰勒公式：</p>
<p><img src="https://www.zhihu.com/equation?tex=f%28x%29%3Df%28x_0%29%2Bf%27%28x_0%29%28x-x_0%29%2B%5Cfrac%7Bf%27%27%28x_0%29%7D%7B2%21%7D%28x-x_0%29%5E2%2B%5Ccdots+%5C%5C" alt="[公式]"></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://www.zhihu.com/question/22320408">牛顿插值的几何解释是怎么样的</a></li>
<li><a href="https://www.zhihu.com/question/58333118">如何直观的理解拉格朗日插值法</a></li>
<li><a href="https://www.zhihu.com/question/21149770">如何通俗地解释泰勒公式</a></li>
</ol>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title>对基于Next的Blog进行美化</title>
    <url>/2020/08/10/beautify-next/</url>
    <content><![CDATA[<p>接下来我们来介绍一下基于 Next 主题的进阶优化</p>
<h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>首先我们先将 Hexo 默认的主题修改为 Next 主题：</p>
<ul>
<li>安装 Next 主题</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure>
<ul>
<li>修改网站配置文件 <code>_config.yml</code> ，找到 theme 字段，修改为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
  <a id="more"></a>
<ul>
<li>修改<strong>主题的配置文件</strong><code>_config.yml</code> ，找到 Schemes 字段，选择自己喜欢的 Next 主题：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Next主题可选样式</span><br><span class="line"># Schemes</span><br><span class="line">## Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</span><br><span class="line">## Mist - Muse 的紧凑版本，整洁有序的单栏外观</span><br><span class="line">## Pisces - 双栏 Scheme，小家碧玉似的清新</span><br><span class="line"># scheme: MUSE</span><br><span class="line">scheme: Mist</span><br><span class="line"># scheme: Pisces</span><br><span class="line"># scheme: Gemini</span><br></pre></td></tr></table></figure>
<h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><ul>
<li>修改<strong>网站配置文件</strong> <code>_config.yml</code> ，找到 language 字段，修改为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure>
<h3 id="初始化设置"><a href="#初始化设置" class="headerlink" title="初始化设置"></a>初始化设置</h3><ul>
<li>配置文章默认格式，这样我们就有了一个 blog 的默认格式了        </li>
</ul>
<p>修改<code>/scaffolds/post.md</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">top: false</span><br><span class="line">cover: false</span><br><span class="line">password:</span><br><span class="line">toc: true</span><br><span class="line">mathjax: true</span><br><span class="line">summary:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><ul>
<li>修改<strong>主题的配置文件</strong><code>_config.yml</code> ，找到 avatar 字段，修改 url 字段</li>
</ul>
<h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>菜单的设置同样是通过修改<strong>主题的配置文件</strong><code>_config.yml</code> ：</p>
<ul>
<li>找到 <code>menu</code> 字段，如图：</li>
</ul>
<p><img src="/.io//2020-08-10_18-51.png" alt="2020-08-10_18-51"></p>
<p>我们可以看到菜单的配置是有三个部分组成的，第一项是菜单项，第二项是菜单的名称，最后一项是菜单所对应的图标。在 Next 中所调用的图标都是由 <a href="http://fontawesome.io/">Font Awesome</a> 提供的。</p>
<p>NexT 默认的菜单项有（标注*的项表示需要手动创建这个页面）：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">键值</th>
<th style="text-align:left">设定值</th>
<th style="text-align:left">显示文本（简体中文）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">home</td>
<td style="text-align:left"><code>home: /</code></td>
<td style="text-align:left">主页</td>
</tr>
<tr>
<td style="text-align:left">archives</td>
<td style="text-align:left"><code>archives: /archives</code></td>
<td style="text-align:left">归档页</td>
</tr>
<tr>
<td style="text-align:left">categories</td>
<td style="text-align:left"><code>categories: /categories</code></td>
<td style="text-align:left">分类页 *</td>
</tr>
<tr>
<td style="text-align:left">tags</td>
<td style="text-align:left"><code>tags: /tags</code></td>
<td style="text-align:left">标签页 *</td>
</tr>
<tr>
<td style="text-align:left">about</td>
<td style="text-align:left"><code>about: /about</code></td>
<td style="text-align:left">关于页面 *</td>
</tr>
<tr>
<td style="text-align:left">commonweal</td>
<td style="text-align:left"><code>commonweal: /404.html</code></td>
<td style="text-align:left">公益 404 *</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>当然，我们也可以自己创建新的菜单选项，但是由于不是官方支持的菜单项，所以无法进行翻译，所以需要自己进行设置：</li>
</ul>
<p>在 <code>languages/zh-CN.yml</code> 配置文件中找到 <code>menu</code> 字段，进行一个键值对的添加</p>
<h3 id="设置侧边栏"><a href="#设置侧边栏" class="headerlink" title="设置侧边栏"></a>设置侧边栏</h3><p>侧边栏的设置包括两方面，一是侧边栏的位置，另一个是侧边栏出现的时机。都是通过修改<strong>主题的配置文件</strong><code>_config.yml</code> 来实现的，找到 <code>sidebar</code> 字段：</p>
<ol>
<li><p>通过修改 <code>position</code> 字段，可以将侧边栏置左或者置右</p>
</li>
<li><p>通过修改 <code>display</code> 字段，可以设置侧边栏显示的时机：</p>
<ul>
<li><code>post</code> - 默认行为，在文章页面（拥有目录列表）时显示</li>
<li><code>always</code> - 在所有页面中都显示</li>
<li><code>hide</code> - 在所有页面中都隐藏（可以手动展开）</li>
<li><code>remove</code> - 完全移除</li>
</ul>
</li>
</ol>
<h3 id="增加文章阅读统计"><a href="#增加文章阅读统计" class="headerlink" title="增加文章阅读统计"></a>增加文章阅读统计</h3><h4 id="配置-LeanCloud"><a href="#配置-LeanCloud" class="headerlink" title="配置 LeanCloud"></a>配置 LeanCloud</h4><p>我们要达到文章访问人数的统计就需要拿到相应的 AppID 以及 AppKey ，下面就是详细过程：</p>
<ul>
<li><strong>创建应用</strong><ul>
<li>在出现的界面点击<code>创建应用</code></li>
<li>新建 class，注意为了保证对 Next 主题的修改兼容，新建的 Class 名字必须为 <code>Counter</code>，对于所有权限的设置都选择 <code>所有用户</code></li>
<li>选择左侧的 <code>设置 -&gt; 应用Keys</code> ，由此我们就获得了需要的 AppID 以及 AppKey</li>
</ul>
</li>
<li>修改<strong>主题的配置文件</strong><code>_config.yml</code> ，找到 <code>leancloud_visitors</code> 字段，修改其中的 AppID 和 AppKey ，并将 <code>security</code> 字段改为 <code>false</code></li>
</ul>
<blockquote>
<p>需要特别说明的是：记录文章访问量的唯一标识符是文章的<code>发布日期</code>以及<code>文章的标题</code>，因此请确保这两个数值组合的唯一性，如果你更改了这两个数值，会造成文章阅读数值的清零重计。</p>
</blockquote>
<h3 id="开启图片预览"><a href="#开启图片预览" class="headerlink" title="开启图片预览"></a>开启图片预览</h3><ul>
<li>下载插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 fancybox</span><br></pre></td></tr></table></figure>
<ul>
<li>移动到 Next 主题下，我的路径为 <code>node_modules/hexo-theme-next/source/lib/</code></li>
<li>修改<strong>主题的配置文件</strong><code>_config.yml</code> ，找到 <code>fancybox</code> 字段，修改为 <code>true</code></li>
</ul>
<h3 id="利用不蒜子在底部增加访客计数"><a href="#利用不蒜子在底部增加访客计数" class="headerlink" title="利用不蒜子在底部增加访客计数"></a>利用不蒜子在底部增加访客计数</h3><ul>
<li>修改<strong>主题的配置文件</strong><code>_config.yml</code> ，找到 <code>busuanzi_count</code> 字段，修改为 <code>true</code></li>
<li>将其中 <code>post_views</code> 字段改为 <code>false</code></li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
  <entry>
    <title>由浅入深入门 QAP</title>
    <url>/2020/09/02/QAP/</url>
    <content><![CDATA[<p>原文：<a href="https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649">Quadratic Arithmetic Programs: from Zero to Hero</a></p>
  <a id="more"></a>
<h1 id="由浅入深入门-QAP"><a href="#由浅入深入门-QAP" class="headerlink" title="由浅入深入门 QAP"></a>由浅入深入门 QAP</h1><p><img src="/.io//1_YD-ckgBfmmmRBCyVlhp8YQ.png" alt="ZK-Snarks 入门步骤"></p>
<p>上述步骤应该被分成两部分。首先，zk-SNARKs 无法直接应用到任何计算问题上;相反，为了解决问题，你必须将问题转换为适当的”形式”，即 “二次算术程序”（QAP），这种形式的转换本身就不是一件容易的事情。除了将函数的代码转换为 QAP 之外，一起运行的还有另一个过程，这样，如果对代码有输入，就可以创建相应的解决方案(有时称为 QAP 的“见证”)。在此之后，还有另一个相当复杂的过程来为这个 QAP 创建实际的“零知识证明”，还有一个单独的过程来验证别人传给你的证据，但是这些细节超出了本文的范围,就不在细述了。</p>
<p>在下面示例中，我们将选择一个非常简单的问题：求一个三次方程的解: <script type="math/tex">x^3 + x + 5 == 35</script> (提示:答案是 3 )。<br>这个问题很简单，但是重要的，你可以由此案例看到所有的功能是如何发挥作用的。</p>
<p>用编程语言描述以上方程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qeval</span>(<span class="params">x</span>):</span></span><br><span class="line">    y = x**<span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> x + y + <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>我们在这里使用的简单编程语言支持基本的四则运算 (+、-、*、/) 、恒等幂指数 (<script type="math/tex">x^7，但不是x^y</script>) 和变量赋值，理论上这足以强大到可以借此进行任何计算(只要计算步骤的数量是有界的;且不允许循环)。注意模 (%) 和比较运算符 (&lt;、&gt;、≤≥) 是不支持，这是因为在有限循环群里面，没有求余运算和比较运算的高效方案 (幸亏如此，如果有任何一种方法可以做到这一点，那么椭圆曲线密码破环的速度将超过“二分查找”和“中国剩余定理”) 。</p>
<p>同时你也可以利用位分解来实现取模和比较运算，（例如：<script type="math/tex">13 = 2^3 + 2^2 + 1=8+4+1</script>) 作为辅助输入，以证明这些分解的正确性，并可以借助<strong>二进制电路</strong>中进行数学运算；在有限域算法中，执行等式检查 (==) 也是可行的，甚至更容易一些，但这些细节我们现在都不讨论。我们也可以通过扩展来支持条件句（例如将语句：<code>if x &lt; 5: y = 7; else: y = 9;</code> 转换为算术形式：<code>y = 7 * (x &lt; 5) + 9 * (x &gt;= 5);</code>）不过请注意，条件中的两条“路径”都需要执行，如果您有许多嵌套的条件，那么这会导致大量开销。</p>
<p>现在让我们一步一步地经历这个过程。如果你想自己做任何代码，我<a href="https://github.com/ethereum/research/tree/master/zksnark">在这里用Python实现了一段代码</a>（仅用于教育目的；还没有准备好为现实世界的 zk-SNARKs 制作 QAPs  !）</p>
<h2 id="拍平"><a href="#拍平" class="headerlink" title="拍平"></a>拍平</h2><p>第一步是一个“拍平”的过程，我们把原来的代码（这可能包含任意复杂的语句和表达式）分解为最简单的表达式，这种表达式有两种形式:<br> 1- <code>x = y</code> （ y 可以是变量或数字)<br> 2- <code>x = y(op)z</code> ( op 可以 +,-,*,/，y 和 z 可以是变量，数字或子表达式)。</p>
<p>你可以把这些表述看成是电路中的逻辑门。上述表达式<code>x**3 + x + 5</code>的扁平化过程结果如下:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">sym_1 = x * x</span><br><span class="line">y = sym_1 * x <span class="comment">//相当于实现了幂函数y = x**3</span></span><br><span class="line">sym_2 = y + x</span><br><span class="line">~<span class="keyword">out</span> = sym_2 + <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>你可以认为上述的每一行声明都是一个电路中的逻辑门，与原始代码相比，这里我们引入了两个中间变量<code>sym_1</code> 和 <code>sym_2</code>，还有一个表示输出的冗余变量 <code>~out</code>，不难看出“拍平”后的代码和原始代码是等价的。</p>
<h2 id="转化为-R1CS"><a href="#转化为-R1CS" class="headerlink" title="转化为 R1CS"></a>转化为 R1CS</h2><p>现在，我们把它转换成一个称为<code>R1CS</code>（Rand-1 Constraint System）的东西。<code>R1CS</code>是由三个向量<code>(a, b, c)</code>组成的序列，假设<code>R1CS</code>的解是一个向量<code>s</code>，其中<code>s</code>必须满足等式 <script type="math/tex">s \cdot a * s \cdot b - s \cdot c = 0</script> ，其中 <script type="math/tex">\cdot</script> 代表的是<strong>内积运算</strong>（将两个向量对应位置的成员相乘，结果再累加）。例如，下面是一个完美的 R1CS ：</p>
<p><img src="/.io//1_wp6bmXoPEU_zZHzJFRq6IQ.png" alt></p>
<p>但是上述例子只有一个约束，我们需要把它衍生到多个约束：接下来我们要将每个逻辑门（即 “拍平” 后的每一个声明语句）转化成一个约束（即一个<code>(a, b, c)</code>三向量组），转化的方法取决于声明是什么四则运算 (+,-,*,/) 和声明的参数是变量还是数字。每个向量的长度等于在系统中变量的个数，包括还需要在第一个分量位置处引入一个冗余变量<code>~one</code>来表示数字1，输入的变量，以及冗余变量 <code>~out</code> ，还有中间变量。就我们这个系统而言，一个向量所对应的 6 个分量是(可以是其他顺序，只要对应起来即可)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;~one&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;~out&#x27;</span>, <span class="string">&#x27;sym_1&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;sym_2&#x27;</span></span><br></pre></td></tr></table></figure>
<p>解向量就会按照上述顺序包含这些变量。</p>
<p>现在我们举一个例子：</p>
<p>在第一个门中 <script type="math/tex">sym_1 = x * x</script> ：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">b = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">c = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>如果解向量 <code>s</code> 的第二个标量是 3，第四个标量是 9，无论其他标量是多少，都成立，因为：a = 3 <em> 1, b = 3 </em> 1, c = 9 <em> 1，即`a </em> b = c`。同样，如果 s 的第二个标量是 7，第四个标量是 49，也会通过检查，第一次检查仅仅是为了验证第一个门的输入和输出的一致性。</p>
<p>而第二个门中 <script type="math/tex">y = sym_1 * x</script> ：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">b = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">c = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>同理，第三个门 <script type="math/tex">sym_2 = y + x</script> ：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] </span><br><span class="line">c = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>第四个门 <script type="math/tex">~out = sym_2 + 5</script> ：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">c = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>现在，我们假设<code>x = 3</code>，根据第一个门，得到<code>sym_1 = 9</code>，根据第二个门得到<code>y = 27</code>，根据第三个门，得到<code>sym_2 = 30</code>，根据第四个门得到<code>~out = 35</code>，因此，根据：<code>&#39;~one&#39;, &#39;x&#39;, &#39;~out&#39;, &#39;sym_1&#39;, &#39;y&#39;, &#39;sym_2&#39;</code>，可以得到：s = [1, 3, 35, 9, 27, 30] 。</p>
<p>如果假设不同的 x ，都可以得到不同的 s ，但所有 s 都可以用来验证 (a, b, c) </p>
<p>现在我们得到了四个约束的 R1CS ，完整的 R1CS 如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">B</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">C</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="从-R1CS-到-QAP"><a href="#从-R1CS-到-QAP" class="headerlink" title="从 R1CS 到 QAP"></a>从 R1CS 到 QAP</h2><p>下一步是将这个<code>R1CS</code>转换成<code>QAP</code>的形式，它们的底层逻辑是相同的，只是 QAP 使用多项式来代替了内积。我们是这样做的：将 4 组长度为 6 的 3 个向量转化为 6 组 长度为 3 的三次多项式，在每个 x 坐标处这些多项式的结果代表一个约束条件。也就是说，如果我们求出 x=1 处的多项式，我们就得到了第一组向量，如果我们求出 x=2 处的多项式，我们就得到第二组向量，以此类推。</p>
<p>我们可以用拉格朗日插值来做这个变换。拉格朗日插值法解决的问题是：如果你有一组点(即 (x, y) 坐标对），然后对这些点做拉格朗日插值得到一个经过所有这些点的多项式。我们通过分解问题：对于每个 x 坐标，我们都构建这样一个多项式，使得该多项式通过（x,y）这个点同时对于其他的点通过的都是 y=0 的点，最终我们将这样的多项式累加起来就可以得到我们想要的多项式了。</p>
<p>让我们举一个例子。假设我们想要一个多项式经过(1,3),(2,2)和(3,4)。我们首先做一个多项式，经过(1,3)(2,0)和(3,0)。事实证明，构建一个在 x=1 时不为 0 而在剩下两点 y 均为 0 的多项式是很容易的，我们只要做以下多项式即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(x - 2) * (x - 3)</span><br></pre></td></tr></table></figure>
<p>如下图：</p>
<p><img src="/.io//1_wsBN9VA71EXm2L4EV-hwcw.png" alt></p>
<p>然后，在 y 轴方向“拉伸”，使用如下方程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(x - 2) * (x - 3) * 3 &#x2F; ((1 - 2) * (1 - 3))</span><br></pre></td></tr></table></figure>
<p>得出：</p>
<script type="math/tex; mode=display">y=1.5x^2-7.5x+9</script><p><img src="/.io//1_8agIwBEX5YJ1HyZ4K5r5Gw.png" alt></p>
<p>然后我们在对另外两个点也做相似的操作。最后我们把三个多项式相加，可以得到：</p>
<script type="math/tex; mode=display">y=1.5x^2-5.5x+7</script><p><img src="/.io//13960264-8e4d51f0625c6ec4.webp" alt></p>
<p>就是我们想要的坐标方程。上述算法需要 <script type="math/tex">O(n^3)</script> 时间复杂度，因为有 n 个点，每个点都需要 <script type="math/tex">O(n^2)</script> 时间将多项式相乘。稍微思考一下，这就可以减少到 <script type="math/tex">O(n^2)</script> 的时间，再多思考一下，使用快速的傅里叶变换算法等等，它可以进一步减少时间复杂度——这是一个关键的优化，因为在 zk- SNARKS 中使用的函数通常有成千上万个门。</p>
<p>现在我们使用拉格朗日差值公式来将 R1CS 转化为 QAP 形式。我们先求出四个约束所对应的每个 a 向量的第一个值的多项式，也就是说使用拉格朗日插值定理求过点 (1,0), (2,0), (3,0), (4,0) 的多项式，类似的我们可以求出其余的四个约束所对应的每个向量的第 i 个值的多项式。<br>这里，直接给出答案：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A polynomials</span><br><span class="line">[<span class="number">-5.0</span>, <span class="number">9.166</span>, <span class="number">-5.0</span>, <span class="number">0.833</span>]</span><br><span class="line">[<span class="number">8.0</span>, <span class="number">-11.333</span>, <span class="number">5.0</span>, <span class="number">-0.666</span>]</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line">[<span class="number">-6.0</span>, <span class="number">9.5</span>, <span class="number">-4.0</span>, <span class="number">0.5</span>]</span><br><span class="line">[<span class="number">4.0</span>, <span class="number">-7.0</span>, <span class="number">3.5</span>, <span class="number">-0.5</span>]</span><br><span class="line">[<span class="number">-1.0</span>, <span class="number">1.833</span>, <span class="number">-1.0</span>, <span class="number">0.166</span>]</span><br><span class="line">B polynomials</span><br><span class="line">[<span class="number">3.0</span>, <span class="number">-5.166</span>, <span class="number">2.5</span>, <span class="number">-0.333</span>]</span><br><span class="line">[<span class="number">-2.0</span>, <span class="number">5.166</span>, <span class="number">-2.5</span>, <span class="number">0.333</span>]</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line">C polynomials</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line">[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>]</span><br><span class="line">[<span class="number">-1.0</span>, <span class="number">1.833</span>, <span class="number">-1.0</span>, <span class="number">0.166</span>]</span><br><span class="line">[<span class="number">4.0</span>, <span class="number">-4.333</span>, <span class="number">1.5</span>, <span class="number">-0.166</span>]</span><br><span class="line">[<span class="number">-6.0</span>, <span class="number">9.5</span>, <span class="number">-4.0</span>, <span class="number">0.5</span>]</span><br><span class="line">[<span class="number">4.0</span>, <span class="number">-7.0</span>, <span class="number">3.5</span>, <span class="number">-0.5</span>]</span><br></pre></td></tr></table></figure>
<p>这些系数是升序排序的，例如上述第一个多项式是 <script type="math/tex">0.833 x^3 - 5 x^2 + 9.166  x - 5</script> 。这组多项式（加上将在后面解释的 Z 多项式）构成了此特定 QAP 实例的参数。 请注意，对于您要使用 zk-SNARKs 进行验证的每个功能，到目前为止所有工作都只需完成一次。 一旦生成了 QAP 参数，就可以重用它们。</p>
<p>我们尝试评估所有这些多项式在 x = 1 的情况。 在 x = 1 处评估多项式只是意味着将所有系数相加（对于所有 k，因为 <script type="math/tex">1^k = 1</script> ），所以并不困难。 我们得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A results at x&#x3D;1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">B results at x&#x3D;1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">C results at x&#x3D;1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>我们在这里拥有的与我们在上面创建的第一个逻辑门的三个向量的集合完全相同。</p>
<h2 id="检查-QAP"><a href="#检查-QAP" class="headerlink" title="检查 QAP"></a>检查 QAP</h2><p>那么这种疯狂转换的意义何在？ 答案是，我们现在可以通过对多项式进行点积检查来同时检查所有约束，而不是单独检查R1CS中的约束。</p>
<p><img src="/.io//1_QD2EfVsbNguEXrjKJwNVMg.png" alt></p>
<p>因为在这种情况下，点积的检查是多项式的一系列加法和乘法，所以结果本身就是多项式。如果之前我们用来表示逻辑门的每个 x 坐标处求值的所得多项式等于零，则意味着通过了所有检查；如果所得的多项式至少在代表逻辑门的 x 坐标之一中求值给出非零值，则意味着进出该逻辑门的值不一致（即门为y = x <em> sym_1，但提供的值可能是x = 2，sym_1 = 2和y = 5）。<br>请注意，所得多项式本身不必为零，实际上在大多数情况下不必为零。只要在与某个逻辑门相对应的所有点的结果均为零，它就可以在不与任何逻辑门相对应的点处具有任何行为。为了检查正确性，我们实际上并未在对应每个门的每个点处计算多项式 $$t = A \cdot s </em> B \cdot s - C \cdot s<script type="math/tex">；取而代之的是，我们将 t 除以另一个多项式 Z ，然后检查 Z 是否整除了 t ——也就是说，除法 t / Z 没有余数。
Z 定义为</script>（x-1）<em>（x-2）</em>（x-3）…$$ ——在对应于逻辑门的所有点上等于零的最简单多项式。基础的代数知识告诉我们，在所有这些点上等于零的多项式都必须是该最小多项式的倍数，并且如果多项式是 Z 的倍数，则在这些点上任何一个的求和都将为零；这种对等关系使我们的工作更加轻松。<br>现在，让我们实际使用上述多项式进行点积的检查。首先，中间多项式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A . s &#x3D; [43.0, -73.333, 38.5, -5.166]</span><br><span class="line">B . s &#x3D; [-3.0, 10.333, -5.0, 0.666]</span><br><span class="line">C . s &#x3D; [-41.0, 71.666, -24.5, 2.833]</span><br></pre></td></tr></table></figure>
<p>以上多项式经过：<script type="math/tex">t = A \cdot s * B \cdot s - C \cdot s</script> 计算后得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; [-88.0, 592.666, -1063.777, 805.833, -294.777, 51.5, -3.444]</span><br></pre></td></tr></table></figure>
<p>最小多项式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Z &#x3D; (x - 1) * (x - 2) * (x - 3) * (x - 4)</span><br></pre></td></tr></table></figure>
<p>即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Z &#x3D; [24, -50, 35, -10, 1]</span><br></pre></td></tr></table></figure>
<p>现在计算多项式相除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h &#x3D; t &#x2F; Z &#x3D; [-3.666, 17.055, -3.444]</span><br></pre></td></tr></table></figure>
<p>h 必须是没有任何余数的整除。</p>
<p>因此，我们有了针对 QAP 的解决方案。如果我们试图伪造我们从中获取此 QAP 解决方案中 R1CS 解决方案里的任何变量——例如，将最后一个变量设置为 31 而不是 30 ，那么我们将得出多项式未能通过其中一项检查（在这种情况下） ，则 x = 3 处的结果等于 -1 而不是 0 ），而且 t 不会是 Z 的倍数；相反，除以 t / Z 可以得到 [-5.0，8.833，-4.5，0.666] 的余数。<br>注意，以上只是简化； “在现实世界中”，加法，乘法，减法和除法运算不是通过正则数发生的，而是通过有限域元素进行的——这是一种自相干的怪异算法，因此我们所知道和喜爱的所有代数定律仍然成立，但是所有答案都是某个有限大小的元素的集合，对于某些 n ，通常在 0 到 n-1 范围内的整数。例如，如果 n = 13 ，则 1/2 = 7 （并且7 <em> 2 = 1），3 </em> 5 = 2，依此类推。使用有限域算术消除了对舍入误差的担心，并使系统能够很好地处理椭圆曲线，这最终对使 zk-SNARK 协议变得真正安全。<br>特别感谢 Eran Tromer 协助我向我解释了有关 zk-SNARK 内部运作的许多细节。</p>
]]></content>
      <categories>
        <category>blockchain | ZKP | 翻译</category>
      </categories>
  </entry>
  <entry>
    <title>Blog 搭建错误总结</title>
    <url>/2020/08/10/next-bug-fix/</url>
    <content><![CDATA[<p>在本篇 Blog 中将会对在部署过程中发现的问题进行总结</p>
<h2 id="访客计数出错"><a href="#访客计数出错" class="headerlink" title="访客计数出错"></a>访客计数出错</h2><ul>
<li><strong>错误场景：</strong></li>
</ul>
<p>在使用 LeanCloud 时，发现填入 AppId 以及 AppKey 之后阅读数量出错，错误代码为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Counter not initialized! More info at console err msg.</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>解决方案：</strong></li>
</ul>
<ol>
<li>将 <code>security</code> 字段改为 <code>false</code></li>
<li><p>安装了插件<code>hexo-leancloud-counter-security</code>（命令行执行<code>npm install hexo-leancloud-counter-security</code>）</p>
<a id="more"></a></li>
</ol>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
  <entry>
    <title>使用hexo以及github pages搭建个人网站</title>
    <url>/2020/08/09/build-blogs/</url>
    <content><![CDATA[<p>本篇博客是记录本人在搭建该博客时的操作。</p>
<h2 id="Pre-build"><a href="#Pre-build" class="headerlink" title="Pre-build"></a>Pre-build</h2><ul>
<li><p>在 github 上新建一个 repo ，命名为 xxxx.github.io ，但是具体的域名要在 Settings 中寻找</p>
</li>
<li><p>在 repo 的 Settings 中选择 github pages 的主题，这里还可以看到具体的 url 地址</p>
<p><img src="/.io//2020-08-09_23-01.png" alt="2020-08-09_23-01"></p>
<a id="more"></a>
</li>
<li><p>安装 Hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装扩展</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="Building"><a href="#Building" class="headerlink" title="Building"></a>Building</h2><ul>
<li><p><strong>将本地的博客项目与 github 连接起来</strong>，打开博客根目录下生成的 <code>_config.yml</code> 文件，这是博客的配置文件，可以修改博客的相关配置。</p>
<p>现在我们修改最后一行的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:xxxxxx&#x2F;xxxxxxx.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>这里设置为 ssh 的连接方式，方便后续的 deploy ，如果使用 https 方式，则每次 deploy 都需要输入 github 用户名和密码。</p>
</li>
<li><p><strong>写文章与发布文章</strong>，然后输入<code>hexo new post “xxxxx”</code>，这样就新建了一篇文章。</p>
<p>此时，在<code>source/_posts</code>目录下会生成一个 md 文件，这样你就可以开始编写博客了。</p>
<p>完成后，在根目录输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>就可以本地预览效果，你可以通过<code>localhost:4000</code>查看效果</p>
<p>最后，你可以通过<code>hexo d</code>将博客盛传到 github 上，此时你就可以通过 Settings 中的 url 地址进行访问</p>
</li>
</ul>
<hr>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>注意新建的 repo 中的 xxxx.github.io 最好和用户名相同，否则会出现 hexo 不起作用的效果</li>
</ul>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
  </entry>
  <entry>
    <title>pedersen commitment</title>
    <url>/2020/09/01/pedersen-commitment/</url>
    <content><![CDATA[<p><strong>承诺方案（commit scheme）</strong>主要目的是提供<strong>“针对双方的信息互换方案”</strong>，通过隐藏关键值来避免信息泄露。Pedersen Commitment也不例外，但不同于普通的承诺方案，其可以通过<strong>不揭露相关信息来达到确认双方是否拥有某一个相同的值。</strong>承诺方案有两个基本性质：<strong>隐藏性（Hiding）</strong>和<strong>绑定性（Binding）</strong>。隐藏性为承诺值不会泄露任何关于消息 m 的信息；绑定性是指任何恶意的承诺方都不能将承诺打开为非 m 的消息且验证通过，即接收方可以确信 m 是和该承诺对应的消息。</p>
  <a id="more"></a>
<h2 id="Pedersen-Commitment-原理解析"><a href="#Pedersen-Commitment-原理解析" class="headerlink" title="Pedersen Commitment 原理解析"></a>Pedersen Commitment 原理解析</h2><p>Pedersen Commitment 是密码学中承诺方案的一种，于1992年被 Torben Pryds Pedersen 在 “Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing” 一文中提出。目前 Pedersen Commitment 主要搭配椭圆曲线密码学使用，其核心可以用一项公式表达：</p>
<script type="math/tex; mode=display">C=r*G+v*H</script><p>其中， C 为承诺值，G、H 为托顶椭圆曲线上的两个生成元，r 代表盲因子，v 代表原始信息。由于 G、H 为椭圆曲线上的两个生成元，所以 <script type="math/tex">r*G\ 和\ v*H</script> 均为相应的曲线上的公钥，根据椭圆曲线的离散对数难的问题，我们几乎无法解出私钥，即 r、v 。</p>
<p>在 Pedersen Commitment 里面，发送和接收方是知道明文（转账的金额）的。 Pedersen Commitment 是要保证参与双方知道（才能生成正确的承诺），但是其他人不知道的情况下，能验证明文（转账的金额）是承诺的明文。下面介绍一下具体的原理：</p>
<p>假设 Alice 给 Bob 转账金额 n ，Alice 生成自己的承诺：<script type="math/tex">C_{Alice}=n*G+r_{Alice}*H</script> ，其中 <script type="math/tex">r_{Alice}</script> 为 Alice 选择的盲化因子。 而 Bob 类似生成如下的承诺： <script type="math/tex">C_{Bob}=n*G+r_{Bob}*H</script> ，双方公布自己的承诺，然后双方分别相减：</p>
<p><script type="math/tex">C_{Alice}-C_{Bob}=n*G+r_{Alice}*H-n*G-r_{Bob}*H=(r_{Alice}-r_{Bob})*H</script> ，然后双方都公布这个差值，如果完全相同，那么就可以保证 n 是相等的。</p>
<h2 id="范围证明"><a href="#范围证明" class="headerlink" title="范围证明"></a>范围证明</h2><p>如果 A 有 100 个币的余额，付 90 个币给B，那么这笔交易大概长这样：<img src="/.io//2020-09-02_19-46.png" alt></p>
<p>由于 ECC 的加法同态，如果我们有一个加法同态的加密方法 E ，我们就可以把这笔交易转化成：<img src="/.io//2020-09-02_19-48.png" alt></p>
<p>显而易见，此时我们会有一个巨大的漏洞，虽然 Pederson Commitment 证明了数字之间的关系，但是并没有限制任何数字的取值区间。那也就说，A 就可以使坏，提交一笔交易，说自己要付 -100 个币给 B ，然后“找”给自己 200 个币，这样一来一去，等式还是成立的。 A 就可以借此无限印钞，从而摧毁整个系统。</p>
<p><img src="/.io//2020-09-02_20-04.png" alt></p>
<p>解决方案的话，我们在这里就不详述了，大致就是引入一个范围证明的电路，在之后的文章里会具体介绍。</p>
<h2 id="Pedersen-Commitment-应用"><a href="#Pedersen-Commitment-应用" class="headerlink" title="Pedersen Commitment 应用"></a>Pedersen Commitment 应用</h2><p>先说结论，考虑到应用难度，UTXO 结构相比账户结构更适合以 Pedersen Commitment 来实施匿名方案。</p>
]]></content>
      <categories>
        <category>cryptography | blockchain</category>
      </categories>
  </entry>
  <entry>
    <title>代理重加密综述</title>
    <url>/2020/08/12/pre/</url>
    <content><![CDATA[<p>随着云计算的发展，我们越来越趋向于将数据保存在第三方云端上，同时这些数据的安全性也越来越收到用户的重视。在传统的加密技术中，用户的数据被加密之后存储到云端，当用户需要这些数据时，从云端获取加密的数据，然后使用自己的私钥对这些加密的数据进行解密从而获得明文信息。</p>
  <a id="more"></a>
<h2 id="代理重加密"><a href="#代理重加密" class="headerlink" title="代理重加密"></a>代理重加密</h2><p>首先我们需要了解，如果我们要做一次点对点的分享，用户 Alice 想把自己的一份原文发送给 Bob ，当然不可能直接把原文发送过去，这样容易造成数据的泄露，那么我们可以通过加密的手段使得他人拦截到的数据无法被破译，最简单的方式就是 Alice 自己生成一对公私钥对，然后用自己的公钥对原文进行加密，然后将私钥交给 Bob ，使得 Bob 可以通过该私钥对密文进行解密从而获得原文。But, hold on ~~ 如果 Alice 和 Bob 之间可以相互安全的传送私钥，那还有什么必要去进行加密这一步呢？私钥如果被拦截，任何人都可以反解出原文是什么了，如果双方可以安全的传输私钥而不被其他人拦截，那何不直接传输原文呢？</p>
<p>于是就衍生出了另一种方案，需要双方<strong>各自生成一对公私钥对</strong>，然后就是这样一个过程：</p>
<ol>
<li>Alice 使用 Bob 的公钥对需要分享的信息进行加密</li>
<li>将密文发送给 Bob</li>
<li>Bob 接收到密文，用自己的私钥进行解密从而获得原文</li>
</ol>
<p>由此我们可以了解到这种方案的缺陷，如果我们需要将这段信息分发给多个用户，那 Alice 本人就需要用所有用户提供的公钥对自己的原文进行加密后再分发，这无疑大大增加了发送方的负担，让发送方体验非常糟糕。那么，我们是否可以借助一个代理方，将这个过程释放到一个性能更高的代理方，但是有可以保证自己的原文不被泄露呢，于是就引出了<strong>代理重加密</strong>这个概念。</p>
<blockquote>
<p>代理重加密是一种公钥加密方案，允许用户 Alice 将她的解密权限“委托”给另一个用户 Bob 。Alice 可以委托一个半可信代理将一个被自己所加密的密文转化为一个相当于被 Bob 所加密的密文。</p>
<p>同时，半可信代理是独立于 Alice 运行的，这也解决了增加 Alice 负担的问题。当然，我们也需要保证代理是无法看到 Alice 的原文的，也不能将 Alice 的消息重新加密给 Alice 没有授予解密权限的用户。</p>
</blockquote>
<p>假设有这样一个场景，Alice 有事儿要出门，希望让 Bob 来处理自己不在家这段时间收到的邮件，但是又不希望把自己邮箱的密码告诉 Bob ，所以希望将自己这段时间邮箱里收到的邮件都转发给 Bob ，但是害怕邮箱的管理人员会看到自己的邮件，所以将邮件加密后指定 Bob 作为接收人，让 Bob 可以通过自己的私钥去解密这些邮件。但是这样的需求要如何做到呢，由于邮件的密文形式是由 Alice 的公钥进行加密的，即使直接转发给了 Bob ，他也无法进行解密，最简单的方法就是将 Alice 的私钥发送给邮件服务器，邮件服务器对密文进行解密然后再通过 Bob 的公钥对明文加密，这样转发给 Bob 的密文就可以通过 Bob 的私钥进行解密了。但是与此同时邮件服务器这端就获取了 Alice 的明文信息，这也是 Alice 无法接受的。</p>
<p>那么，到底该如何做到呢？</p>
<h2 id="Umbral"><a href="#Umbral" class="headerlink" title="Umbral"></a>Umbral</h2><p>这里具体介绍一种方案的原理。下图的三个框表明了这些操作各自分属于 Alice ，Proxy ，Bob 。</p>
<p><img src="/.io//2020-08-23_23-07.png" alt="2020-08-23_23-07"></p>
<p>首先我们明确一下在 Umbral 中的各个操作的意义。</p>
<h3 id="KeyGen-amp-amp-ReKeyGen"><a href="#KeyGen-amp-amp-ReKeyGen" class="headerlink" title="KeyGen &amp;&amp; ReKeyGen"></a>KeyGen &amp;&amp; ReKeyGen</h3><ul>
<li><strong>KeyGen()：</strong> 生成一组公私钥对</li>
<li><strong>ReKeyGen(<script type="math/tex">sk_A,pk_B</script>,N,t)：</strong> 通过 Alice（授权人） 的私钥以及 Bob（被授权人） 的公钥，以及分片的数量 N 和门限值 t，生成一组 kfrag </li>
</ul>
<h3 id="Encapsulation-amp-amp-Decapsulation"><a href="#Encapsulation-amp-amp-Decapsulation" class="headerlink" title="Encapsulation &amp;&amp; Decapsulation"></a>Encapsulation &amp;&amp; Decapsulation</h3><ul>
<li><strong>Encapsulation(<script type="math/tex">pk_A</script>)：</strong> 可以根据公钥 pka 生成一个对称密钥 K 以及一个特殊的结构 capsule</li>
<li><strong>Decapsulation(<script type="math/tex">sk_A</script>,capsule)：</strong> 可以根据一个私钥和一个 capsule 反推出相应的对称密钥 K</li>
</ul>
<h3 id="Re-Encapsulation-amp-amp-Fragments-Decapsulation"><a href="#Re-Encapsulation-amp-amp-Fragments-Decapsulation" class="headerlink" title="Re-Encapsulation &amp;&amp; Fragments Decapsulation"></a>Re-Encapsulation &amp;&amp; Fragments Decapsulation</h3><ul>
<li><strong>ReEncapsulation(kFrag, capsule)：</strong> 通过输入一个生成的 kfrag 结构以及 capsule ，生成一个 capsule 的 frag 结构，即 cfrag </li>
<li><strong>DecapsulateFrags(<script type="math/tex">sk_B,(cFrags)^t_{i=1},</script> capsule)：</strong> 通过 Bob 的私钥和收到的 capsule ，对一组 cfrag 反推出对密文加密的对称公钥 K </li>
</ul>
<p>接下来，我们来剖析一下在这些操作中具体做了些什么：</p>
<p>首先，我们先定义了 <script type="math/tex">g,U\ \in \ \mathbb{G}</script> ，<script type="math/tex">\mathbb{G}</script> 指的是一个循环群，g 和 U 都是作为公私钥转化时的底数。</p>
<ul>
<li><p><strong>ReKeyGen(<script type="math/tex">sk_A</script> , <script type="math/tex">pk_B</script> , N,t)：</strong></p>
<ol>
<li>取一个随机数 <script type="math/tex">x^A \ \in \ \mathbb{Z}_q</script> ，计算出以此为私钥所得的公钥 <script type="math/tex">X^A=g^{x^A}</script> </li>
<li>将 <script type="math/tex">x_A</script> ，<script type="math/tex">pk_$B$ ，</script>(pk_B)^{x^A}<script type="math/tex">级联并求得其 Hash 值，即求得</script>d=H( X_A ，pk_B ，(pk_B)^{x^A})<script type="math/tex">，d 即为这对临时密钥对  (</script>x^A<script type="math/tex">,</script>X^A$$) 和 Bob 这端公私钥对之间一个非交互式的 DH 密钥交互的结果，我们借助 d 来使得两端的重加密密钥生成过程变成非交互式。</li>
<li>取 t-1 个随机数 <script type="math/tex">f_i \ \in \ \mathbb{Z}_q</script>，同时计算 <script type="math/tex">f_0=sk_A*d^{-1} \  mod \ q</script> </li>
<li>构造这样一个 t-1 阶的多项式 <script type="math/tex">f(x)=f_0+f_1x+f_2x^2+\ ...\ +f_{t-1}x^{t-1}</script></li>
<li>计算 <script type="math/tex">D=H(pk_A ，pk_b ，(pk_B)^{sk_A})</script></li>
<li>取两个随机数 <script type="math/tex">y,id\ \in \mathbb{Z}_q</script> ，计算 <script type="math/tex">s_x=H(id,D)，Y=g^y</script> ，将 <script type="math/tex">s_x</script> 代入多项式，求得 <script type="math/tex">rk=f(s_x)</script> ，将 rk 代入，求得 <script type="math/tex">U_1=U^{rk}</script> 。</li>
<li>将上述值代入，求得 <script type="math/tex">z_1=H(Y,id,pk_A,pk_B,U_1,X_A)，z_2=y-a*z_1</script> </li>
<li>定义 kFrag 的结构为一个这样的元组 <script type="math/tex">(id,rk,X_A,U_1,z_1,z_2)</script></li>
<li>将 6-8 重复 N 次，由此获得一个大小为 N 的元组数组 kFrags</li>
</ol>
</li>
<li><p><strong>Encapsulation(<script type="math/tex">pk_A</script>)：</strong></p>
<ol>
<li>取两个随机数 <script type="math/tex">r,u\ \in \mathbb{Z}_q</script> ，计算 <script type="math/tex">E=g^r，V=g^u</script> </li>
<li>根据 E 和 V ，我们求得 <script type="math/tex">s=u+r*H(E,V)，K=KDF((pk_A)^{r+u})</script> ，KDF 是一个生成密钥的函数，可以类似的认为是一个随机预言机</li>
<li>由此，我们定义 capsule 这个结构为一个这样的元组 <script type="math/tex">(E,V,s)</script> ，同时我们也得到了一个用于加密的对称密钥 K  </li>
</ol>
</li>
<li><p><strong>CheckCapsule(capsule)：</strong></p>
<p>如果我们需要验证 capsule 是否正确，可以通过计算 <script type="math/tex">g^s=V*E^{H(E,V)}</script> 两端是否相等来判断，该公式的推导过程如下：</p>
<script type="math/tex; mode=display">
g^s=g^{u+r*H(E,V)}=V*E^{H(E,V)}</script></li>
<li><p><strong>Decapsulate(<script type="math/tex">sk_A</script>, capsule)：</strong></p>
<p>既然我们可以通过公钥去打包一份 capsule 并由此生成一个对称密钥来对明文加密，那么我们一定也就可以通过对应的私钥和 capsule 来重新生成这个我们所需要的对称密钥 K 。即 <script type="math/tex">K=KDF((E*V)^{sk_A})</script> ，下面是推导过程：</p>
<script type="math/tex; mode=display">
K=KDF((E*V)^{sk_A})\\=KDF(g^{r*sk_A+u*sk_A})\\=KDF(g^{sk_A*(r+u)})\\=KDF((pk_A)^{r+u})</script><p>在计算前我们会先进行对 CheckCapsule 这个函数的调用，以确保 capsule 的有效性。</p>
</li>
<li><p><strong>ReEncapsulation(kFrag, capsule)：</strong></p>
<p>已知会输入 kFrag 和 capsule 这两个元组，其结构为 <script type="math/tex">kFrag=(id,rk,X_A,U_1,z_1,z_2)，capsule=(E,V,s)</script> ，首先我们会先调用 CheckCapsule 这个函数，以确保 capsule 的有效性。然后我们计算 <script type="math/tex">E_1=E^{rk}，V_1=V^{rk}</script> ，随即得出一个新的元组 <script type="math/tex">cFrag=(E_1,V_1,id,X_A)</script></p>
</li>
<li><p><strong>DecapsulateFrags(<script type="math/tex">sk_B, (cFrags)^t_{i=1},</script> capsule)：</strong></p>
<p>我们会在 Bob 端收到多个 cFrag ，只要达到门限值，我们就可以进行反推。现在我们需要通过上述的输入来推出用于加密明文的对称密钥 K ：</p>
<ol>
<li>计算 <script type="math/tex">D=H(pk_A,pk_B,pk_A^{sk_B})</script></li>
<li>计算 <script type="math/tex">s_{x,i}=H(id_i,D)</script> 并由此组成大小为 t 的数组 S </li>
<li>计算 <img src="/.io//2020-08-26_23-59.png" style="zoom: 67%;"></li>
<li>计算<script type="math/tex">E^{'}=\prod_{i=1}^t{({E_{1,i}})^{\lambda_{i,S}}}，V^{'}=\prod_{i=1}^t{({V_{1,i}})^{\lambda_{i,S}}}</script> </li>
<li>计算 <script type="math/tex">d=H(X_A,pk_B,X_A^{sk_B})</script> </li>
<li>最后计算对称密钥 <script type="math/tex">K=KDF((E^{'}*V^{'})^d)</script></li>
</ol>
<p>？？？发生了什么，为什么突然就算出了对称密钥 K ，下面我们就来仔细分析一下 Alice 和 Bob 两端所计算的值</p>
<ul>
<li><p>在 Alice 端，我们计算了<script type="math/tex">D=H(pk_A ，pk_b ，(pk_b)^{sk_A})</script> ，而在 Bob 端，我们同样计算了 <script type="math/tex">D=H(pk_A,pk_B,pk_A^{sk_B})</script> ，由于</p>
<script type="math/tex; mode=display">
pb_B^{sk_A}=g^{b*a}=g^{a*b}=pk_A^{sk_B}</script><p>于是，我们可以推出两端的 D 是相等的</p>
</li>
<li><p>在 Alice 端，我们计算了<script type="math/tex">d=H( X_A ，pk_B ，(pk_B)^{x^A})</script> ，而在 Bob 端，我们同样计算了 <script type="math/tex">d=H(X_A,pk_B,X_A^{sk_B})</script> ，由于</p>
<script type="math/tex; mode=display">
(pk_B)^{x^A})=g^{sk_B*x^A}=X_A^{sk_B}</script><p>于是，我们可以推出两端的 d 是相等的</p>
</li>
<li><p>在 Alice 端，我们构建了一个多项式组 <script type="math/tex">rk_i=f(s_{x_i})</script>：</p>
<p><img src="/.io//2020-08-27_10-42.png" alt></p>
<p>根据拉格朗日插值法，我们可以得出该多项式的解，有兴趣的同学可以看我写的另一篇文章 <a href="https://whisker17.github.io/2020/08/18/Interpolation/#more">《插值法综述》</a> 。该多项式的解为：</p>
<p><img src="/.io//2020-08-27_11-27.png" alt="多项式组的解"></p>
<p>而在 Bob 端，我们通过计算 <script type="math/tex">E^{'}\ 和\ V^{'}</script> 来反推密钥，那么 <script type="math/tex">E^{'}\ 和\ V^{'}</script> 到底是什么呢，我们来计算一下：</p>
<p>已知 <script type="math/tex">E_1=E^{rk}，那么\ E_{1,i}=E^{rk_i}</script> ，于是我们可推：</p>
<p><img src="/.io//2020-08-27_11-45.png" alt></p>
<p>那么</p>
<p><img src="/.io//2020-08-27_11-46.png" alt></p>
<p>根据多项式组的解以及 <script type="math/tex">\lambda_{i,S}</script> ，我们可以得出：</p>
<p><img src="/.io//2020-08-27_12-05.png" alt> </p>
<p>又因为在 Alice 端我们知道 <script type="math/tex">f_0=sk_A*d^{-1} \  mod \ q</script> ，而在 Bob 端的 <script type="math/tex">f_0</script> 如上，那么：</p>
<script type="math/tex; mode=display">
K_{Alice}=KDF((E*V)^{sk_A})=KDF((E^{'}*V^{'})^d)=K_{Bob}</script><p>得证。</p>
</li>
</ul>
</li>
</ul>
<p>这里又出现了一个新的问题：Bob 是否可以算出 Alice 的私钥？</p>
<p>因为我们可以看到<img src="/.io//2020-08-27_12-11.png" style="zoom:67%;"> ，那么我们好像就可以算出 Alice 的私钥了，这里我们可以知道，在 Bob 端我们是已知 <script type="math/tex">d \ 和\ \lambda_{i,S}</script> 的，但是我们是不知道 <script type="math/tex">rk_i</script> 的，但是 Proxy 是知道这个参数的，这就引出了这个方案的一个前提要求，即：<strong>要求 Proxy 是一个半可信的机构</strong></p>
<h2 id="PyUmbral"><a href="#PyUmbral" class="headerlink" title="PyUmbral"></a>PyUmbral</h2><p>下面介绍一下具体的操作，即PyUmbral，之前提到的 Umbral 的 Python 实现版本。</p>
<h3 id="Key-Generation"><a href="#Key-Generation" class="headerlink" title="Key Generation"></a>Key Generation</h3><ul>
<li>在 Alice 端生成两组非对称加密的公私钥对</li>
<li>在 Bob 端生成一组非对称加密的公私钥对</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> umbral <span class="keyword">import</span> pre, keys, signing</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate Umbral keys for Alice.</span></span><br><span class="line">alices_private_key = keys.UmbralPrivateKey.gen_key()</span><br><span class="line">alices_public_key = alices_private_key.get_pubkey()</span><br><span class="line"></span><br><span class="line">alices_signing_key = keys.UmbralPrivateKey.gen_key()</span><br><span class="line">alices_verifying_key = alices_signing_key.get_pubkey()</span><br><span class="line">alices_signer = signing.Signer(private_key=alices_signing_key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate Umbral keys for Bob.</span></span><br><span class="line">bobs_private_key = keys.UmbralPrivateKey.gen_key()</span><br><span class="line">bobs_public_key = bobs_private_key.get_pubkey()</span><br></pre></td></tr></table></figure>
<h3 id="Encryption"><a href="#Encryption" class="headerlink" title="Encryption"></a>Encryption</h3><ul>
<li>通过 Alice 的公钥对明文进行加密，从而获得密文和 capsule</li>
<li>相应的，我们也可以通过 Alice 的私钥对密文以及 capsule 进行解密，从而获得明文</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Encrypt data with Alice&#x27;s public key.</span></span><br><span class="line">plaintext = <span class="string">b&#x27;Proxy Re-Encryption is cool!&#x27;</span></span><br><span class="line">ciphertext, capsule = pre.encrypt(alices_public_key, plaintext)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decrypt data with Alice&#x27;s private key.</span></span><br><span class="line">cleartext = pre.decrypt(ciphertext=ciphertext,</span><br><span class="line">                        capsule=capsule,</span><br><span class="line">                        decrypting_key=alices_private_key)</span><br></pre></td></tr></table></figure>
<h3 id="Re-Encryption-Key-Fragments"><a href="#Re-Encryption-Key-Fragments" class="headerlink" title="Re-Encryption Key Fragments"></a>Re-Encryption Key Fragments</h3><ul>
<li>Alice 可以使用自己的私钥生成 kfrags</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Alice generates &quot;M of N&quot; re-encryption key fragments (or &quot;KFrags&quot;) for Bob.</span></span><br><span class="line"><span class="comment"># In this example, 10 out of 20.</span></span><br><span class="line">kfrags = pre.generate_kfrags(delegating_privkey=alices_private_key,</span><br><span class="line">                             signer=alices_signer,</span><br><span class="line">                             receiving_pubkey=bobs_public_key,</span><br><span class="line">                             threshold=<span class="number">10</span>,</span><br><span class="line">                             N=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Re-Encryption"><a href="#Re-Encryption" class="headerlink" title="Re-Encryption"></a>Re-Encryption</h3><ul>
<li>Bob 端通过 Alice 的公钥以及验证公钥和自己的公钥完整 capsule，并且通过接收到一定数量的 kfrag 得到相应的 cfrag</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Several Ursulas perform re-encryption, and Bob collects the resulting `cfrags`.</span></span><br><span class="line"><span class="comment"># He must gather at least `threshold` `cfrags` in order to activate the capsule.</span></span><br><span class="line"></span><br><span class="line">capsule.set_correctness_keys(delegating=alices_public_key,</span><br><span class="line">                             receiving=bobs_public_key,</span><br><span class="line">                             verifying=alices_verifying_key)</span><br><span class="line"></span><br><span class="line">cfrags = list()           <span class="comment"># Bob&#x27;s cfrag collection</span></span><br><span class="line"><span class="keyword">for</span> kfrag <span class="keyword">in</span> kfrags[:<span class="number">10</span>]:</span><br><span class="line">  cfrag = pre.reencrypt(kfrag=kfrag, capsule=capsule)</span><br><span class="line">  cfrags.append(cfrag)    <span class="comment"># Bob collects a cfrag</span></span><br></pre></td></tr></table></figure>
<h3 id="Decryption-by-Bob"><a href="#Decryption-by-Bob" class="headerlink" title="Decryption by Bob"></a>Decryption by Bob</h3><ul>
<li>最终 Bob 可以通过 cfrags 以及自己的私钥对接收到的密文进行解密</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bob activates and opens the capsule</span></span><br><span class="line"><span class="keyword">for</span> cfrag <span class="keyword">in</span> cfrags:</span><br><span class="line">  capsule.attach_cfrag(cfrag)</span><br><span class="line"></span><br><span class="line">bob_cleartext = pre.decrypt(ciphertext=ciphertext,</span><br><span class="line">                            capsule=capsule,</span><br><span class="line">                            decrypting_key=bobs_private_key)</span><br><span class="line"><span class="keyword">assert</span> bob_cleartext == plaintext</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，我们来总结一下 PRE 与传统 PKE 的对比。</p>
<p>在静态场景下，传统做法有一个较长的初始化过程。在实际运用中，重加密方法需要较大的计算需求，但节约了一部分存储，两种方式差距不是特别明显。</p>
<p>但一般情况下，文件系统的用户和内容都是动态的，此时重加密做法的优势明显。具体来说，在增加用户时，传统做法需要本地对已有的所有加密密钥进行加密，可能花费很长时间。在增加文件时，重加密做法下，数据分享者只需要使用自己的公钥去加密对称密钥即可，而传统做法需要做M次非对称加密。更新文件加密密钥时，重加密做法的数据分析者只需要使用自己的公钥去加密对称密钥即可（无需再次生成重加密密钥），而传统做法需则需要重新执行初始化过程。另外，服务端拥有更强的计算能力，重加密算法把这些计算过程让服务端更多承担，尽量减少客户端的计算，符合架构设计原理。最后，重加密算法的弹性更好，一般来说，x不会是一个太大的数，当文件访问稀疏时，在一开始就执行多次可能无用的加密是巨大的浪费。</p>
<p>总的来说：</p>
<ol>
<li>对于同一类明文，我们使用的相同的对称密钥进行加密，与对端的用户无关</li>
<li>对于对端不同的用户，我们需要在本端针对不同的用户生成不同的重加密密钥，与本段文件无关</li>
<li>在做完授权的部分后，本端将不再参与其他过程，解放客户端的压力，使之成为一个非交互性的系统</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://spqrlab1.github.io/papers/ateniese-proxy-reenc-ndss05.pdf">Improved Proxy Re-Encryption Schemes with Applications to Secure Distributed Storage</a></li>
<li><a href="https://www.doc88.com/p-2703873549583.html">代理重加密若干问题研究</a></li>
<li><a href="https://github.com/nucypher/umbral-doc/blob/master/umbral-doc.pdf">UMBRAL: A THRESHOLD PROXY RE-ENCRYPTION SCHEME</a></li>
<li><a href="https://arxiv.org/pdf/1707.06140.pdf">NuCypher KMS: Decentralized key management system</a></li>
<li><a href="https://github.com/nucypher/pyUmbral/">PyUmbral</a></li>
</ol>
]]></content>
      <categories>
        <category>cryptography | blockchain | 代理重加密</category>
      </categories>
  </entry>
  <entry>
    <title>ring signature</title>
    <url>/2020/08/24/ring-signature/</url>
    <content><![CDATA[<p>隐私是用户最关心的问题之一，而环签名解决的问题是，我对你说了一句话，但是你只知道是某一群人中有人对你说了这句话，而不知道这群人里具体哪个人说的。简言之就是，我把自己藏进了人群里。环签名通过将实际签名者的公钥藏进一个公钥集合，来达到保护签名者身份的目的。例如，某协会主席提出一种议案，但如果协会成员中有人提出反对意见则议案需被取消。但投反对票的会员又不想暴露自己的身份，因此他可以用环签名的技术，将自己的反对票用自己的私钥和其他协会成员的公钥进行签名。签名之后所有协会成员都可以看到协会中有人反对该项议案，但不知道确切的反对者是谁。</p>
  <a id="more"></a>
<p>环签名也被称为 CryptoNote，由<strong>群签名</strong>演化而来，典型的应用案例是门罗币。群签名是利用<strong>公开的群公钥和群签名</strong>进行验证的方案，其中群公钥是公开的，群成员可以生成群签名，验证者能利用群公钥验证所得群签名的正确性，但不能确定群中的正式签名者。<strong>可是群管理员可以撤销签名</strong>，揭露真正的签名者群签名，这是群签名的关键问题所在。</p>
<p><strong>环签名方案则去掉了群组管理员</strong>，不需要环成员之间的合作，<strong>签名者利用自己的私钥和集合中其他成员的公钥就能独立的进行签名</strong>，集合中的其他成员可能不知道自己被包含在了其中。这种方案的优势除了能够对签名者进行无条件的匿名外，环中的其他成员也不能伪造真实签名者签名。外部攻击者即使在获得某个有效环签名的基础上，也不能伪造一个签名。</p>
<p>那么环签名是如何做到这点的呢？接下来我们用椭圆曲线来举例说明环签名的具体技术关键点和原理。</p>
<h2 id="环签名的生成过程"><a href="#环签名的生成过程" class="headerlink" title="环签名的生成过程"></a>环签名的生成过程</h2><p>假设我们的签名者拥有一对公私钥对 (sk,pk) ，由于我们采用的是 ECC 加密算法，所以 <script type="math/tex">pk=sk*G</script> ，G 为椭圆曲线上的基点，也被称为生成元。这里的 “*” 是倍乘，即 sk 个 G 点在椭圆曲线上进行加法运算。</p>
<p>以上是前提准备，接下来我们来介绍一下具体的步骤：</p>
<ol>
<li><p>签名方找来 n-1 个其他人的公钥，并编好序号，然后将自己的公钥随机插入其中，组成一个包含 n 个公钥的集合，即 <script type="math/tex">pk_0,pk_1,pk_2,\ ...\ ,pk_{i-1},pk_i,pk_{i+1},\ ...\ ,pk_{n-1}</script> ，其中 <script type="math/tex">pk_i</script> 为签名方的公钥。</p>
</li>
<li><p>签名方随机生成 n-1 个随机数 <script type="math/tex">s_0,s_1,s_2,\ ...\ ,s_{i-1},s_{i+1},\ ...\ ,s_{n-1}</script> ，分别与除了 <script type="math/tex">pk_i</script> 以外的 n-1 个公钥一一对应，而 <script type="math/tex">s_i</script> 会在后面的计算中求出。</p>
</li>
<li><p>签名方随机生成 k ，并计算 <script type="math/tex">k*G</script>  ，这里我们假设 <script type="math/tex">k*G=s_i*G+c_i*pk_i</script> ，具体的意义我们可以先不用了解，但是我们知道如果我们可以得到 <script type="math/tex">pk_i\ 的私钥\ sk_i\ 且知道\ c_i\ 和\ k</script> ，根据 <script type="math/tex">pk=sk*G</script> ，我们代入原式，就可以求出 <script type="math/tex">s_i</script> 。</p>
</li>
<li><p>接下来引入第二个式子： <script type="math/tex">c_x=Hash(m,s_{x-1}*G+c_{x-1}*pk_{x-1})</script> 。我们可以看出来，这是一个递推的式子，而且我们注意到 Hash 函数的右半部分和过程 3 中的式子是一致的。连立两个等式，我们可以求得： <script type="math/tex">c_{i+1}=Hash(m,s_i*G+c_i*pk_i)=Hash(m,k*G)</script> 。以此计算：</p>
<script type="math/tex; mode=display">
c_{i+2}=Hash(m,s_{i+1}*G+c_{i+1}*pk_{i+1})\\
...\\
c_{n-1}=Hash(m,s_{n-2}*G+c_{n-2}*pk_{n-2})\\
c_{0}=Hash(m,s_{n-1}*G+c_{n-1}*pk_{n-1})\\
c_{1}=Hash(m,s_{0}*G+c_{0}*pk_{0})\\
...\\
c_{i}=Hash(m,s_{i-1}*G+c_{i-1}*pk_{i-1})\\</script><p><img src="/.io//640.jpeg" alt="计算环签名的过程"></p>
</li>
</ol>
<ol>
<li>有了 <script type="math/tex">c_i</script> 之后，代入步骤 3 的等式中，即 <script type="math/tex">k*G=s_i*G+c_i*sk_i*G</script> ，推出 <script type="math/tex">k=s_i+c_i*sk_i</script> ，由此我们也可以推出 <script type="math/tex">s_i</script> 了 </li>
</ol>
<p><img src="/.io//640.webp" alt></p>
<ol>
<li><script type="math/tex">s_i</script> 一旦求出，环签名的环就形成了，此时我们就可以消去 k ，即：</li>
</ol>
<script type="math/tex; mode=display">
c_0=Hash(m,s_{n-1}*G+c_{n-1}*pk_{n-1})\\
c_1=Hash(m,s_{0}*G+c_{0}*pk_{0})\\
...\\
c_{n-1}=Hash(m,s_{n-2}*G+c_{n-2}*pk_{n-2})\\</script><ol>
<li>最后明文 m 的环签名数据为：</li>
</ol>
<script type="math/tex; mode=display">Signature={c_0,pk_0,\ ...\ ,pk_{n-1},s_0,\ ...\ ,s_{n-1}}</script><h2 id="环签名的验证过程"><a href="#环签名的验证过程" class="headerlink" title="环签名的验证过程"></a>环签名的验证过程</h2><p>验证着根据 <script type="math/tex">c_0,pk_0,\ ...\ ,pk_{n-1},s_0,\ ...\ ,s_{n-1}</script> ，明文 m 和步骤 4 的等式依次求出 <script type="math/tex">c_1,c_2,\ ...\ ,c_{n-1}</script> ，最后根据 <script type="math/tex">c_{n-1}\ 求出\ c^{'}_0</script> ，对比<script type="math/tex">c_0\ 和\ c^{'}_0</script> 是否相等，如果相等则签名有效，否则无效。</p>
<h2 id="CryptoNote"><a href="#CryptoNote" class="headerlink" title="CryptoNote"></a>CryptoNote</h2><p>现在我们来结合实际，在现实中， Monero 的底层就使用了环签名的概念，即 CryptoNode 。</p>
<p>首先我们引入 <strong>Stealth Address</strong> 的概念。</p>
<p><img src="/.io//challenge_response.jpg" alt="challenge_response"></p>
<ol>
<li>Bob 需要选取两个数 a 和 b 作为私钥，并在 ECC 椭圆曲线上计算出对应的公钥 A 和 B 。A=aG, B=bG，G是曲线上一个公用的基点。然后 Bob 将计算出来的这两个公钥 A、B 向全网公布。</li>
<li>现在 Alice 想向给 Bob 发起一笔交易，需要先获取到 Bob 公布的公钥 A、B ，然后选取一个随机整数 r 作为另一个私钥，通过公式 P=Hs(rA)G+B ，计算出公开地址 P 。</li>
<li>Alice 再通过公式 R=rG ，将随机整数 r 转换成 R 。</li>
<li>Alice 创建转账交易，并将计算出的 R、P 一起记录到交易中公布到区块链上。由于使用了哈希函数，所以根据 R、P 是无法推断出 A、B ，从而无法获悉接收人是 Bob。</li>
<li>Bob 扫描区块链上的交易，根据公式 P’=Hs(aR)G+bG 计算 P’，如果交易的接收人是 Bob ，根据 aR = arG = rA ，所以 P’= Hs(aR)G+B = Hs(rA)G+B = P ，也就是检测到 P’=P 时，就可以认为这笔交易是发给 Bob 的。</li>
<li>Bob根据公式 x=Hs(aR)+b ，计算得到一个整数，因为有 xG = Hs(aR)G+bG = Hs(aR)G+B = P , 符合 ECC 算法定义，x 就是针对公钥 P 的私钥，而这个私钥连给钱的 Alice 也无法推算出。日后 Bob 就可以使用这个私钥来花费这笔钱了。</li>
</ol>
<h3 id="CryptoNote-方案"><a href="#CryptoNote-方案" class="headerlink" title="CryptoNote 方案"></a>CryptoNote 方案</h3><ol>
<li>生成随机数q，w</li>
<li>对q，w进行转换</li>
</ol>
<p><img src="/.io//q_w_switch.jpg" alt="q_w_switch"></p>
<ol>
<li>零交互转换</li>
</ol>
<p><img src="/.io//zero_switch.jpg" alt="zero_switch"></p>
<ol>
<li>得到 challenge 和 response</li>
</ol>
<p><img src="/.io//challenge_response (1" alt="challenge_response">.jpg)</p>
<ol>
<li>最终签名</li>
</ol>
<p><img src="/.io//ring_signature.jpg" alt="ring_signature"></p>
<ol>
<li>根据 signature 保存的及其他数据，运用算法计算出 L，R</li>
</ol>
<p><img src="/.io//calc_L_R.jpg" alt="calc_L_R"></p>
<ol>
<li>效验签名是否正确</li>
</ol>
<p><img src="/.io//verify_ring_signature.jpg" alt="verify_ring_signature"></p>
<p>综上所述<br>签名就是：随机数 + 要签名的数据，已有的数据 + 算法 —-&gt; 签名结果<br>效验就是：签名结果 + 要签名的数据，已有的数据 + 算法 —-&gt; 效验结果</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾一下签名的整个过程，关键的巧妙点在于，如果知道私钥 <script type="math/tex">sk_i</script> ，那么就可以反推出 <script type="math/tex">s_i</script> ，使 <script type="math/tex">c_1,c_2,\ ...\ ,c_{n-1}</script> 形成一个环。就好像签名者找了一根铁丝，数学保证了只有拥有私钥的人，才能把铁丝的两头接起来，形成铁丝环。而且一旦成为铁丝环之后，环的接点处也没有任何痕迹，这使得验证者无法判断铁环是在哪个位置上接起来的。</p>
<p>环签名虽然可以用来做到一定程度的匿名性，不过毕竟真实的签名者还是会暴露在环中。且在目前的公有链市场上，与环签名相比，零知识证明依然是最佳的匿名方案之一。只是在某些场景下，如果对隐私的要求没有那么高，同时签名方的计算能力又很弱，环签名不失为一个不错的选择。</p>
]]></content>
      <categories>
        <category>cryptography | blockchain</category>
      </categories>
  </entry>
  <entry>
    <title>由 RSA VS ECC 引发的密码学基础普及</title>
    <url>/2020/08/28/rsa-vs-ecc/</url>
    <content><![CDATA[<p>为什么在现阶段众多的区块链项目的选择依旧是 ECC 而不是 RSA 呢？这两种加密算法又有什么区别和各自的优缺点呢？</p>
  <a id="more"></a>
<p>RSA 加密算法是一种非对称加密算法，什么是非对称加密算法呢？简单来说就是加密和解密不是互为逆过程，下面先给大家普及一下<strong>对称加密算法和非对称加密算法的区别</strong>：</p>
<p>如果有这样一个场景， Alice 和 Bob 有想要共享的明文，两者要如何传递这个信息而不用担心被第三方窃听到呢？对于<strong>对称加密</strong>而言，只需要 Alice 和 Bob 双方共同拥有一个密钥， Alice 这边用这个密钥对明文进行加密，然后发送给 Bob 。所有第三方由于没有这个密钥，是无法破解这串密文的，但是到了 Bob 这端， Bob 可以用密钥进行解密，从而得到明文，这样加密和解密是不是就是一个逆过程了。但是，这样的方案有严重的缺陷，实际情况中我们无法让 Alice 和 Bob 提前商量好使用同一个密钥而不被第三方窃听到，如果能做到这样的保证，那我们为什么不直接让双方进行明文的共享呢？</p>
<p>而对于非对称加密而言，密钥有两种：公钥和私钥。公钥用于加密，私钥用于解密。针对当前这个例子， Alice 用公开的公钥对明文进行加密，只有 Bob 拥有这个公钥所对应的私钥，那么也就意味着只有 Bob 才能对这串密文进行解密，这也就达到了我们的目的。</p>
<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>对极大整数做因数分解的难度决定了 RSA 算法的可靠性。也就是说，假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就会极度下降。当然这种可能性是非常低的。现阶段，只有短的 RSA 密钥才可能被暴力破解，但是只要其密钥的长度足够长，用 RSA 加密的信息实际上是不能被破解的。总的来说， RSA 就是利用了：</p>
<ol>
<li>对两个质数相乘很简单，但是将其积分解成两个质数却很难，即 <script type="math/tex">n=p_1*p_2</script> ，已知 p1 和 p2 ，求 n 很简单，但是已知 n ，却很难求得 p1 和 p2 。</li>
<li><script type="math/tex">{m^e}\ mod \ n=c</script> ，已知 m，e，n 求 c 很简单，反之却很难。</li>
</ol>
<p>下面是算法的具体步骤：</p>
<ol>
<li>随机选取两个<strong>不同</strong>的素数 p，q</li>
<li>将 p，q 相乘，即 <script type="math/tex">n=p*q</script> </li>
<li>计算 n 的欧拉函数 <script type="math/tex">\psi(n)</script> ，欧拉函数证明，当 p，q 为不相同的素数时， <script type="math/tex">\psi(n)=(p-1)(q-1)</script> 。</li>
<li>随机选择一个整数 e ，满足两个条件： <script type="math/tex">\psi(n)</script> 与 e 互质，且 1 &lt; e &lt;  <script type="math/tex">\psi(n)</script> 。</li>
<li>计算 e 对于 <script type="math/tex">\psi(n)</script> 的模反元素 d ，即找到一个 d 满足 <script type="math/tex">ed=1\ mod\ \psi(n)</script> 。上述条件等价于 <script type="math/tex">ed-1=k\psi(n)</script> ，求 (d,k) 的整数解。这个方程可以用<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">扩展欧几里得算法</a>求得。</li>
<li>最终把 (e,n) 封装成公钥，(d,n) 封装成私钥。 </li>
</ol>
<p>最终加密的过程即为 <script type="math/tex">C=M^e\ mod \ n</script> ，而解密的过程即为 <script type="math/tex">M=C^d\ mod\ n</script> 。</p>
<h2 id="ECC"><a href="#ECC" class="headerlink" title="ECC"></a>ECC</h2><p>什么是椭圆曲线？<strong>一条椭圆曲线就是一组被 <script type="math/tex">y_2=x^3+ax+b</script> 定义的且满足 <script type="math/tex">4a^3+27b^2\neq0</script> 的点集。</strong>  <script type="math/tex">4a^3+27b^2\neq0</script> 这个条件是为了保证曲线不包含奇点。 </p>
<p>​                                                                                   <img src="/.io//v2-1d205ac7a84a53685519cdf801a32abd_720w.png" alt="不同的椭圆曲线对应的不同形状 ( b=1,a从2到-3 ) "></p>
<p><img src="/.io//v2-06eb5f52f137a038bf2c446a411c4324_720w.png" alt="奇异点：左图，带锐点(式1)；右图，曲线自交（式2）。他们都不是有效的椭圆曲线"></p>
<blockquote>
<p>式1： <script type="math/tex">y^2=x^3</script><br>式2：<script type="math/tex">y^2=x^3-3x+2</script></p>
</blockquote>
<p>随着a和b的不同，椭圆曲线也会在平面上呈现出不同的形状，但他还是很容易辨认的，<strong>椭圆曲线始终是关于x轴对称的。</strong></p>
<p>另外，我们还需要一个无穷处的点作为曲线的一部分，从现在开始，我们将用 0 这个符号表示无穷处的点。如果我们将无穷处的点也考虑进来的话，那么椭圆曲线的表达式精炼为：</p>
<p><img src="https://www.zhihu.com/equation?tex=+%5Cleft%5C%7B+%28x%2C+y%29+%5Cin+%5Cmathbb%7BR%7D%5E2%5C+%7C%5C+y%5E2+%3D+x%5E3+%2B+ax+%2B+b%2C%5C+4+a%5E3+%2B+27+b%5E2+%5Cne+0+%5Cright%5C%7D%5C+%5Ccup%5C+%5Cleft%5C%7B+0+%5Cright%5C%7D" alt="[公式]"></p>
<p>我们已经看到了椭圆曲线的图象，但点与点之间好象没有什么联系。我们能不能建立一个类似于在实数轴上加法的运算法则呢？这就要定义椭圆曲线的加法群，这里需要用到近世代数中<strong>阿贝尔群</strong>。</p>
<h3 id="群"><a href="#群" class="headerlink" title="群"></a>群</h3><p>群是一种代数结构，由一个集合以及一个二元运算所组成。已知集合和运算(G,*)如果是群则必须满足如下要求：</p>
<ul>
<li>封闭性：∀a,b∈G，a*b ∈ G</li>
<li>结合性： ∀a,b,c∈G ，有 (a<em>b)</em>c = a<em> (b</em>c)</li>
<li>单位元：ョe∈G， ∀a ∈G，有e<em>a = a</em>e = a</li>
<li>逆元： ∀a ∈G ，ョb∈G 使得 a<em>b = b</em>a = e</li>
</ul>
<p><strong>阿贝尔群除了上面的性质还满足交换律公理(a<em>b)</em>c = a<em> (b</em>c)</strong></p>
<h3 id="椭圆曲线上的群论"><a href="#椭圆曲线上的群论" class="headerlink" title="椭圆曲线上的群论"></a><strong>椭圆曲线上的群论</strong></h3><p>我们可以在椭圆曲线上定义一个群：</p>
<ol>
<li>群中的元素就是椭圆曲线上的点。</li>
<li>单位元就是无穷处的点0.</li>
<li>相反数P，是关于X轴对称的另一边的点。</li>
<li>加法规则定义如下：取一条直线上的三点（这条直线和椭圆曲线相交的三点），P, Q, R（皆非零），他们的总和等于0，P+Q+R=0。</li>
</ol>
<p><img src="https://pic4.zhimg.com/80/v2-94a567939b88645be83086a53469cfc5_720w.jpg" alt="三个对齐的点的和是0"></p>
<p>请注意最后一条规则，我们仅仅说了需要三个在一条直线上的点，并没有规定他们的顺序。这就意味着，如果P, Q, R在一条直线上的话，他们满足</p>
<p>P+(Q+R)=Q+(P+R)=R+(P+Q)=⋯=0。</p>
<p>这样，我们可以直观的证明：+运算符是符合交换律和结合律的，这是一个阿贝尔群。</p>
<h3 id="几何加法"><a href="#几何加法" class="headerlink" title="几何加法"></a>几何加法</h3><p>任意取椭圆曲线上两点P、Q（若P、Q两点重合，则作P点的切线），作直线交于椭圆曲线的另一点R’，过R’做y轴的平行线交于R，定义P+Q=R。这样，加法的和也在椭圆曲线上，并同样具备加法的交换律、结合律</p>
<p><img src="/.io//v2-2f6f71e39cf1da5723c1a48c5d4eebc2_720w.png" alt></p>
<p>这个几何方法非常有用但是还需要再精炼一下。让我们来回答一下以下几个问题：</p>
<ul>
<li>如果 P = 0或者 Q = 0 呢？很明显，这样我们是画不出线的，无穷远点0 不在xy平面上。但是我们已经定义了0作为单位元。 P + 0 = P 和 Q + 0 = Q，对于任意的P和Q都适用，单位元的作用就是与任意元素运算不改变其值的元素。</li>
<li>如果P = -Q呢？ 在这种情况下，穿过两点的直线是垂直的，没有相交的第三个点。但是呢，如果P是Q的相反数，然后我们将会从相反数的定义中得到 P+Q=P+(−P)=0。</li>
<li>如果P = Q呢？ 在这种情况下，有无数条线会经过这个点。我们假设一个点 <script type="math/tex">Q^{'}\neq P</script> . 当Q’越来越接近P的时候会发生什么？</li>
</ul>
<p><img src="/.io//v2-91b444e4c0e4c386495cb359b064c655_b.gif" alt="当两点越来越接近，穿过两点的直线将会和曲线相切"></p>
<p>当出现切线这种情况，鉴于此我们可以写成P+P=−R，R是曲线和切线的交点，P是切点。</p>
<ul>
<li>如果当P!=Q，但是没有第三点R呢？这种情况与上一条非常相似。事实上，这种情况就是一条直线穿过P和Q与曲线相切。</li>
</ul>
<p><img src="/.io//v2-ba1669a982efc7cd7786c74c372dfecd_b.gif" alt="如果直线和曲线仅相交于两点，这意味着直线是曲线的切线。P+Q的结果显而易见是其中一个点关于X轴的对称点。"></p>
<p>椭圆曲线是连续的，并不适合用于加密；所以，我们必须把椭圆曲线变成离散的点，我们要把椭圆曲线定义在有限域上。于是我们就引出了模运算，将无限域上的点转化到了有限域上，从而达到了加密的意图。</p>
]]></content>
      <categories>
        <category>cryptography | blockchain</category>
      </categories>
  </entry>
  <entry>
    <title>shamir secret share</title>
    <url>/2020/08/13/shamir-secret-share/</url>
    <content><![CDATA[<h2 id="门限机制"><a href="#门限机制" class="headerlink" title="门限机制"></a>门限机制</h2><p>在现实中有效的门限机制在密钥管理的应用中有着举足轻重的地位。我们假设一个场景，有一个秘密被锁在一个箱子里面，一共有 5 个人参与这件事，最少需要 3 个人在场的时候才可以打开这个箱子，那么最少需要多少把锁，而每个人最少需要保管几把钥匙？答案是 10 把锁，6 把钥匙。但是如果将人数扩大到 11 人，最少需要 6 人才能打开箱子，那么锁和钥匙数就会扩大到 462 和 252。抽象成 N 个人，锁的数量为 C(N,N/2)，钥匙数量为 C(N-1,N/2)。随着人数增加，锁和钥匙的数量将会呈现指数级增加，这也会大大增加资源的负担。</p>
<p>我们将某个现实中的问题抽象成为某个数据 D 。我们的目标是将 D 分成 n 份 D1 , D2 , … Dn ，满足：</p>
<p>（1）任意k或多于 k 份 Di 可以很容易地计算出 D</p>
<p>（2）任意 k-1 或少于 k-1 份 Di 信息不能准确计算出 D （所有可能的值相同）</p>
<p>这样的机制称为一个 (k, n) 门限机制。</p>
<a id="more"></a>
<h2 id="拉格朗日插值法"><a href="#拉格朗日插值法" class="headerlink" title="拉格朗日插值法"></a>拉格朗日插值法</h2><p><strong>插值的意义在于拟合，以便求出缺失的点</strong></p>
<p>这里直接给出结论，具体的介绍会另开一篇文章来讲，同时也会介绍各种插值法。</p>
<p>对于某个多项式函数，已知给定的 j+1 个取值点，即 (x0 , f(x0)), … , (xj , f(xj))</p>
<p>假设任意两个不同的 xk 都互不相同，那么这个多项式就为：</p>
<p><img src="/.io//2020-08-17_23-56.png" alt="2020-08-17_23-56"></p>
<p>其中每个 lj(x) 为<strong>拉格朗日基本多项式</strong>（或者称之为<strong>插值基函数</strong>），其表达式为：</p>
<p><img src="/.io//2020-08-17_23-48.png" alt="2020-08-17_23-48"></p>
<h2 id="Shamir-门限方案"><a href="#Shamir-门限方案" class="headerlink" title="Shamir 门限方案"></a>Shamir 门限方案</h2><p>首先，我们知道在在一个平面中，两点可以确定一条直线，三个点可以确定一个 2 次方程，于是我们可以推出给定 K 个不同的点，有且仅有 K-1 次多项式 q(x) 使得 q(xi) = yi 对所有 i 成立。于是我们可以如前文所说的那样：将 D 分成 Di ，随机选择一个 k-1 次多项式：</p>
<p><img src="/.io//2020-08-17_23-59.png" alt="2020-08-17_23-59"></p>
<p>其中 a0 = D 且 D1 = q(1)，D2 = q(2)，… ，Dn = q(n) 。于是，当我们给定任意 Di 值的 k 个子集时，就可以通过插值法找到 q(x) 的系数，然后计算出 D = q(0)。</p>
<hr>
<p>这种 (k,n) 门限机制的<strong>优点</strong>在于：</p>
<ol>
<li>每部分信息的大小不会超过原始数据</li>
<li>当 k 这个数值固定时，Di 可以动态的增删而不会影响别的信息片段</li>
<li>可以在不改变原始数据 D 的情况下轻松的改变 Di 这些信息片段，我们只需要保证这些片段最终可以组成一个恒定的自由项的多项式就可以了。同时这样可变的性质能够提高安全性。</li>
<li>我们也可以利用多项式的系数做一个分层的机制，Di 的片数取决于其重要性。例如，如果我们给公司的主席 3 个 q(x) 的值，每个副主席两个值，每个执行官 1 个值，则（3，n）门限机制给检查签名需要：任意三个执行官或者任意两个执行官其中一个执行官是副主席，或者主席自己。</li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://www5.in.tum.de/lehre/vorlesungen/konkr_math/SS_09/prog/PA3/shamir.pdf">How to share a secret</a></li>
<li><a href="https://www.zhihu.com/question/58333118">如何直观的理解拉格朗日插值法</a></li>
<li><a href="https://ccrma.stanford.edu/~jos/Interpolation/Lagrange_Interpolation.html">Lagrange Interpolation</a></li>
</ol>
]]></content>
      <categories>
        <category>Cryptography | Math</category>
      </categories>
  </entry>
</search>
